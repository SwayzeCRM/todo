<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DFY CRM - Welcome Setup</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>âœ“</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Celebration Animation */
        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        @keyframes success-pulse {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
                opacity: 0;
            }
        }

        @keyframes streak-glow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(251, 191, 36, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
            }
        }

        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confetti-fall 3s linear;
        }

        .success-badge {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 24px;
            font-weight: bold;
            z-index: 10000;
            animation: success-pulse 1s ease-out;
            pointer-events: none;
        }

        .streak-counter {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
            font-size: 13px;
            margin-left: 12px;
        }

        .streak-counter.active {
            animation: streak-glow 2s infinite;
        }

        .streak-counter .streak-icon {
            font-size: 16px;
        }

        .milestone-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease-out;
        }

        .milestone-notification.show {
            transform: translateX(0);
        }

        .milestone-notification h3 {
            margin: 0 0 4px 0;
            font-size: 18px;
        }

        .milestone-notification p {
            margin: 0;
            font-size: 14px;
            opacity: 0.9;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #F5F7FA;
            min-height: 100vh;
            color: #1F2937;
        }

        /* Main Layout - Optimized for Modal */
        .main-container {
            display: flex;
            margin-top: 60px;
            height: calc(100vh - 60px);
            position: relative;
            transition: all 0.3s ease;
        }
        
        
        .main-container.instructions-open .instructions-panel {
            flex: 1;
            width: auto;
            padding: 24px;
            opacity: 1;
            transform: translateX(0);
        }
        
        /* Task Panel (Left Sidebar) */
        .task-panel {
            width: 320px;
            background: white;
            border-right: 1px solid #E5E7EB;
            height: 100%;
            overflow-y: auto;
            transition: width 0.3s ease;
            position: relative;
            flex-shrink: 0;
        }
        
        .task-panel.collapsed {
            width: 0;
            overflow: hidden;
        }
        
        .panel-header {
            padding: 20px;
            border-bottom: 1px solid #E5E7EB;
            background: #F9FAFB;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .panel-header h3 {
            margin: 0;
            font-size: 16px;
            color: #111827;
            font-weight: 600;
        }
        
        .panel-close {
            display: none;
            background: none;
            border: none;
            font-size: 24px;
            color: #6B7280;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
        }
        
        .panel-close:hover {
            background: #F3F4F6;
            color: #111827;
        }
        
        .task-controls {
            padding: 16px;
            border-bottom: 1px solid #E5E7EB;
            background: #F9FAFB;
        }
        
        .task-filter-dropdown {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #D1D5DB;
            border-radius: 6px;
            background: white;
            font-size: 14px;
            color: #374151;
            cursor: pointer;
            margin-bottom: 12px;
        }
        
        .task-filter-dropdown:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }
        
        .search-container {
            position: relative;
        }
        
        .task-search-input {
            width: 100%;
            padding: 8px 12px 8px 36px;
            border: 1px solid #D1D5DB;
            border-radius: 6px;
            background: white;
            font-size: 14px;
            color: #374151;
        }
        
        .task-search-input:focus {
            outline: none;
            border-color: #3B82F6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
        }
        
        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #9CA3AF;
            pointer-events: none;
        }
        
        .task-list-container {
            padding: 16px;
        }

        /* Top Navigation Bar Styles */
        .top-navbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: white;
            border-bottom: 1px solid #E5E7EB;
            z-index: 1000;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        .nav-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 100%;
            padding: 0 20px;
            max-width: 100%;
        }
        
        .nav-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .menu-toggle {
            background: none;
            border: none;
            color: #6B7280;
            cursor: pointer;
            padding: 8px;
            border-radius: 6px;
            transition: all 0.2s;
        }
        
        .menu-toggle:hover {
            background: #F3F4F6;
            color: #111827;
        }
        
        .brand h2 {
            margin: 0;
            font-size: 18px;
            color: #111827;
            font-weight: 600;
        }
        
        .nav-center {
            flex: 1;
            max-width: 400px;
            margin: 0 20px;
        }
        
        .progress-indicator {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .progress-bar-horizontal {
            flex: 1;
            height: 6px;
            background: #E5E7EB;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill-horizontal {
            height: 100%;
            background: linear-gradient(90deg, #3B82F6, #8B5CF6);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-text {
            font-size: 13px;
            color: #6B7280;
            font-weight: 500;
            white-space: nowrap;
        }
        
        .user-menu {
            position: relative;
        }
        
        .user-menu-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            background: none;
            border: 1px solid #E5E7EB;
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .user-menu-btn:hover {
            background: #F9FAFB;
            border-color: #D1D5DB;
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667EEA, #764BA2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }
        
        .user-name {
            font-size: 14px;
            color: #374151;
            font-weight: 500;
        }
        
        .user-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            border: 1px solid #E5E7EB;
            width: 250px;
            display: none;
            z-index: 1001;
        }
        
        .user-dropdown.active {
            display: block;
        }
        
        .dropdown-header {
            padding: 16px;
            border-bottom: 1px solid #E5E7EB;
        }
        
        .dropdown-user-info {
            font-size: 14px;
        }
        
        .dropdown-user-info > div:first-child {
            font-weight: 600;
            color: #111827;
        }
        
        .dropdown-user-info > div:nth-child(2) {
            color: #6B7280;
            margin-top: 4px;
        }
        
        .dropdown-user-info > div:nth-child(3) {
            color: #3B82F6;
            margin-top: 4px;
            font-size: 13px;
        }
        
        .dropdown-divider {
            height: 1px;
            background: #E5E7EB;
        }
        
        .dropdown-item {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            padding: 12px 16px;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
            color: #374151;
        }
        
        .dropdown-item:hover {
            background: #F9FAFB;
        }

        .onboarding-panel {
            flex: 1;
            padding: 24px;
            padding-left: 80px;
            background: #FFFFFF;
            transition: all 0.3s ease-out;
            position: relative;
            overflow: hidden;
        }
        
        /* Tasks list container */
        .tasks-sidebar {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 350px;
            background: #F9FAFB;
            border-right: 1px solid #E5E7EB;
            padding: 70px 20px 20px 20px;
            overflow-y: auto;
            transition: transform 0.3s ease-out;
            z-index: 999;
        }
        
        /* Sidebar collapsed state - default */
        .sidebar-collapsed .tasks-sidebar {
            transform: translateX(-100%);
        }
        
        /* Sidebar expanded state */
        .sidebar-expanded .tasks-sidebar {
            transform: translateX(0);
        }
        
        /* Adjust main content based on sidebar state */
        .sidebar-collapsed .task-content,
        .sidebar-collapsed .user-welcome,
        .sidebar-collapsed #profileSetup {
            margin-left: 0;
            transition: margin-left 0.3s ease-out;
        }
        
        .sidebar-expanded .task-content,
        .sidebar-expanded .user-welcome,
        .sidebar-expanded #profileSetup {
            margin-left: 330px;
            transition: margin-left 0.3s ease-out;
        }

        .container.instructions-open .onboarding-panel {
            flex: 0.5;
        }
        
        .container.instructions-open .sidebar-collapsed {
            flex: 0.15;
        }
        
        .container.instructions-open .sidebar-expanded {
            flex: 0.5;
        }

        .instructions-panel {
            flex: 1;
            background: #F9FAFB;
            color: #1F2937;
            padding: 0;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        .instructions-panel .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #6B7280;
            padding: 40px;
        }
        
        .instructions-panel .empty-state h2 {
            font-size: 28px;
            color: #111827;
            margin-bottom: 12px;
            font-weight: 600;
        }
        
        .instructions-panel .empty-state p {
            font-size: 16px;
            color: #6B7280;
        }

        .header {
            text-align: center;
            margin-bottom: 24px;
            padding: 0 20px;
        }

        .header h1 {
            color: #1F2937;
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 8px;
            letter-spacing: -0.025em;
        }

        .header p {
            color: #6B7280;
            font-size: 16px;
            font-weight: 400;
            line-height: 1.5;
        }

        .progress-bar {
            background: #E5E7EB;
            border-radius: 8px;
            height: 8px;
            margin: 0 20px 24px 20px;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #3B82F6 0%, #2563EB 100%);
            height: 100%;
            border-radius: 8px;
            transition: width 0.4s ease-out;
            width: 0%;
        }

        .task-list {
            space-y: 16px;
        }

        .task-item {
            background: #FFFFFF;
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            padding: 16px;
            transition: all 0.2s ease-out;
            cursor: pointer;
            position: relative;
            margin-bottom: 12px;
            display: block;
        }

        .task-item:hover {
            border-color: #3B82F6;
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .task-item.current {
            background: #DBEAFE;
            border-color: #60A5FA;
        }

        .task-item.current:hover {
            background: #BFDBFE;
            border-color: #3B82F6;
        }

        .task-item.completed {
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.05) 0%, rgba(37, 99, 235, 0.05) 100%);
            border-color: #3B82F6;
        }

        .task-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .task-checkbox {
            width: 20px;
            height: 20px;
            min-width: 20px;
            height: 20px;
            border: 2px solid #E5E7EB;
            border-radius: 6px;
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
            margin-top: 2px;
            transition: all 0.2s ease-out;
            background: #FFFFFF;
        }

        .task-checkbox.checked {
            background: linear-gradient(90deg, #3B82F6 0%, #2563EB 100%);
            border-color: #3B82F6;
        }

        .task-checkbox.checked::after {
            content: 'âœ“';
            position: absolute;
            color: #FFFFFF;
            font-size: 11px;
            font-weight: bold;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .task-details {
            flex: 1;
            pointer-events: none;
        }

        .task-title {
            font-size: 16px;
            font-weight: 600;
            color: #1F2937;
            margin-bottom: 4px;
            line-height: 1.5;
        }

        .task-description {
            color: #6B7280;
            font-size: 14px;
            line-height: 1.5;
            font-weight: 400;
        }

        .instructions-content {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            padding: 20px;
            background: #F9FAFB;
        }

        .instructions-header {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: white;
            border-bottom: 1px solid #E5E7EB;
            gap: 12px;
        }

        .instructions-title {
            font-size: 18px;
            font-weight: 600;
            color: #111827;
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        @media (max-width: 640px) {
            .instructions-title {
                font-size: 16px;
            }
            
            .task-counter {
                font-size: 11px;
                min-width: 35px;
            }
        }
        
        /* Navigation Controls */
        .task-navigation {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-shrink: 0;
        }
        
        .header-complete-btn {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .header-complete-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }
        
        .header-complete-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .task-nav-btn {
            background: #3B82F6;
            border: none;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: bold;
            flex-shrink: 0;
        }
        
        .task-nav-btn:hover:not(:disabled) {
            background: #2563EB;
            transform: scale(1.05);
        }
        
        .task-nav-btn:disabled {
            background: #D1D5DB;
            cursor: not-allowed;
        }
        
        .task-counter {
            font-size: 12px;
            color: #6B7280;
            padding: 0 8px;
            white-space: nowrap;
            min-width: 40px;
            text-align: center;
        }

        .close-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            background: #F3F4F6;
            border: none;
            color: #4B5563;
            width: 28px;
            height: 28px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: background 0.2s ease;
        }

        .close-btn:hover {
            background: #E5E7EB;
        }

        .instructions-body {
            line-height: 1.6;
            color: #1F2937;
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }
        
        /* Custom scrollbar for instructions */
        .instructions-body::-webkit-scrollbar {
            width: 8px;
        }
        
        .instructions-body::-webkit-scrollbar-track {
            background: #F3F4F6;
            border-radius: 4px;
        }
        
        .instructions-body::-webkit-scrollbar-thumb {
            background: #9CA3AF;
            border-radius: 4px;
        }
        
        .instructions-body::-webkit-scrollbar-thumb:hover {
            background: #6B7280;
        }

        .instructions-body h2 {
            margin: 16px 0 8px 0;
            font-size: 18px;
            font-weight: 600;
            color: #1F2937;
        }

        .instructions-body p {
            margin-bottom: 12px;
            color: #4B5563;
        }

        .instructions-body ul {
            margin-left: 20px;
            margin-bottom: 12px;
            color: #4B5563;
        }

        .instructions-body li {
            margin-bottom: 6px;
            color: #4B5563;
        }

        /* Removed duplicate .video-container rule - merged below */
        
        .video-section {
            margin-top: 20px;
            background: transparent !important;
        }

        .video-wrapper {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .video-container {
            position: relative;
            margin: 0 0 20px 0;
            border-radius: 12px;
            overflow: visible;
            background: transparent;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            cursor: pointer;
        }
        
        /* Fullscreen video styles */
        .video-container:fullscreen {
            background: black;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .video-container:fullscreen video {
            width: 100vw;
            height: 100vh;
            object-fit: cover;
        }
        
        .video-container .back-to-instructions {
            display: none;
        }
        
        .video-container:fullscreen .back-to-instructions {
            display: block;
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 12px 24px;
            background: white;
            color: black;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            z-index: 10000;
        }
        
        .video-container:fullscreen .expand-video-btn {
            display: none;
        }
        
        .video-container:fullscreen button[title*="Expand"] {
            display: none;
        }

        .video-container iframe,
        .video-container video {
            position: relative;
            width: 100%;
            aspect-ratio: 16 / 9;
            max-height: 70vh;
            border: none;
            border-radius: 12px;
            background: #000;
            display: block;
            z-index: 1;
        }

        /* Custom Play Overlay */
        .video-play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            cursor: pointer;
            transition: opacity 0.3s ease;
            z-index: 10;
            pointer-events: none;
        }

        .video-play-overlay:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        .video-play-overlay.playing {
            opacity: 0;
        }

        .play-button {
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }

        .video-play-overlay:hover .play-button {
            transform: scale(1.1);
        }

        .play-button svg {
            width: 30px;
            height: 30px;
            fill: #1F2937;
            margin-left: 4px;
        }

        .pause-button svg {
            margin-left: 0;
        }

        /* Video Controls Bar */
        .video-custom-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            opacity: 0;
            transition: opacity 0.3s;
            border-radius: 0 0 12px 12px;
        }

        .video-container:hover .video-custom-controls,
        .video-custom-controls.visible {
            opacity: 1;
        }

        .video-progress-bar {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .video-progress {
            height: 100%;
            background: #3B82F6;
            border-radius: 2px;
            width: 0%;
            position: relative;
        }

        .video-time {
            color: white;
            font-size: 12px;
            min-width: 80px;
            text-align: center;
        }

        .video-controls {
            display: flex;
            justify-content: flex-end;
            padding: 0 4px;
        }

        .expand-video-btn {
            background: #3B82F6;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        
        /* Notification Animations */
        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .expand-video-btn:hover {
            background: #2563EB;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .expand-video-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Expanded Video Mode */
        .video-expanded {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: black;
            z-index: 10000;
            display: none;
        }

        .video-expanded.active {
            display: flex;
            flex-direction: column;
        }

        .video-expanded-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .video-expanded iframe,
        .video-expanded video {
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            border: none;
            border-radius: 0;
        }
        
        /* Play overlay specific to expanded view */
        .video-expanded-content .video-play-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex !important;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            z-index: 100;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        .video-expanded-content .video-play-overlay.playing {
            opacity: 0;
        }
        
        .video-expanded-content .play-button {
            width: 100px;
            height: 100px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        .video-expanded-content .play-button svg {
            width: 40px;
            height: 40px;
            fill: #1F2937;
            margin-left: 5px;
        }

        .video-controls-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10001;
        }

        .video-task-info {
            color: white;
            flex: 1;
        }

        .video-task-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .video-task-progress {
            font-size: 12px;
            opacity: 0.8;
        }

        .exit-expand-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .exit-expand-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        /* Complete Task Button */
        .complete-task-section {
            padding: 20px;
            background: white;
            border-radius: 12px;
            margin-top: 20px;
            text-align: center;
        }
        
        .complete-task-btn {
            background: linear-gradient(135deg, #10B981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .complete-task-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        .complete-task-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Form Styles for Instructions Panel */
        .instruction-form {
            background: #F9FAFB;
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            padding: 20px;
            margin: 16px 0;
        }

        .form-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.9);
            color: #1F2937;
            font-size: 14px;
            margin-bottom: 12px;
            font-family: inherit;
        }

        .form-input:focus {
            outline: none;
            border-color: #3B82F6;
            background: #FFFFFF;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .form-input::placeholder {
            color: #6B7280;
        }

        textarea.form-input {
            resize: vertical;
            min-height: 80px;
        }

        select.form-input {
            cursor: pointer;
        }

        .form-button {
            background: linear-gradient(90deg, #3B82F6 0%, #2563EB 100%);
            color: #FFFFFF;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
        }

        .form-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .form-success-message {
            background: #10B981;
            color: #FFFFFF;
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 12px;
            font-size: 14px;
            font-weight: 500;
        }

        /* Form Labels */
        .instructions-body label {
            display: block;
            color: #374151;
            font-weight: 500;
            margin-bottom: 4px;
            font-size: 14px;
        }

        /* Form Groups */
        .instructions-body .form-group {
            margin-bottom: 16px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #6B7280;
            font-weight: 500;
        }

        .error {
            background: #FEF2F2;
            border: 1px solid #FECACA;
            color: #DC2626;
            padding: 16px;
            border-radius: 8px;
            margin: 20px;
            text-align: center;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            .container {
                width: 95%;
                min-height: auto;
                flex-direction: column;
            }

            .container.instructions-open .onboarding-panel {
                flex: 1;
            }

            .container.instructions-open .instructions-panel {
                flex: 1;
                width: 90%;
                padding: 30px;
            }

            .onboarding-panel {
                padding: 30px 20px;
            }

            .header h1 {
                font-size: 24px;
            }

            .task-content {
                gap: 12px;
            }

            .task-item {
                padding: 16px;
            }
        }

        /* Profile Popup Styles */
        .profile-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        .profile-modal {
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
            width: 90%;
            max-width: 500px;
            padding: 32px;
            position: relative;
        }

        .profile-modal h2 {
            font-size: 24px;
            font-weight: 600;
            color: #1F2937;
            margin-bottom: 8px;
            text-align: center;
        }

        .profile-modal .subtitle {
            color: #6B7280;
            text-align: center;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .profile-form-group {
            margin-bottom: 20px;
        }

        .profile-form-group label {
            display: block;
            font-weight: 500;
            color: #374151;
            margin-bottom: 6px;
        }

        .profile-form-group .required {
            color: #EF4444;
        }

        .profile-form-group input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid #D1D5DB;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.2s ease;
            background: #FFFFFF;
        }

        .profile-form-group input:focus {
            outline: none;
            border-color: #1E40AF;
            box-shadow: 0 0 0 3px rgba(30, 64, 175, 0.1);
        }

        .profile-form-row {
            display: flex;
            gap: 16px;
        }

        .profile-form-row .profile-form-group {
            flex: 1;
        }

        .profile-submit-btn {
            width: 100%;
            background: #1E40AF;
            color: #FFFFFF;
            border: none;
            padding: 14px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-top: 8px;
        }

        .profile-submit-btn:hover {
            background: #1E3A8A;
            transform: translateY(-1px);
        }

        .profile-submit-btn:disabled {
            background: #9CA3AF;
            cursor: not-allowed;
            transform: none;
        }

        @media (max-width: 640px) {
            .profile-modal {
                margin: 20px;
                padding: 24px;
            }
            
            .profile-form-row {
                flex-direction: column;
                gap: 0;
            }
        }

        /* User Welcome Info Styles */
        .user-welcome {
            background: linear-gradient(135deg, #1E40AF 0%, #1E3A8A 100%);
            color: white;
            padding: 20px 24px;
            margin: -24px -24px 24px -24px;
            border-radius: 12px 12px 0 0;
            display: none;
            position: relative;
        }

        .user-welcome h1 {
            font-size: 28px;
            font-weight: 600;
            margin: 0 0 8px 0;
            line-height: 1.2;
        }

        .user-info {
            opacity: 0.9;
            font-size: 13px;
            line-height: 1.4;
        }

        .user-info-row {
            margin: 2px 0;
        }

        .default-header {
            margin-bottom: 24px;
        }

        .default-header h1 {
            font-size: 32px;
            font-weight: 700;
            color: #1F2937;
            margin: 0 0 8px 0;
        }

        .default-header p {
            color: #6B7280;
            font-size: 16px;
            margin: 0;
        }

        /* Edit Profile Button */
        .edit-profile-btn {
            position: absolute;
            top: 20px;
            right: 24px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .edit-profile-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .edit-profile-btn svg {
            width: 16px;
            height: 16px;
        }

        /* Edit Profile Modal Styles */
        .edit-profile-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(8px);
        }

        .edit-profile-modal {
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.25);
            width: 90%;
            max-width: 500px;
            padding: 32px;
            position: relative;
        }

        .edit-profile-modal h2 {
            font-size: 24px;
            font-weight: 600;
            color: #1F2937;
            margin-bottom: 8px;
            text-align: center;
        }

        .edit-profile-modal .subtitle {
            color: #6B7280;
            text-align: center;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .readonly-field {
            background: #F9FAFB !important;
            color: #6B7280 !important;
            cursor: not-allowed;
        }

        .readonly-label {
            color: #9CA3AF;
        }

        /* Toggle Switch Styles */
        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 0;
            border-top: 1px solid #E5E7EB;
        }

        .toggle-info {
            flex: 1;
        }

        .toggle-info label {
            font-weight: 500;
            color: #374151;
            margin: 0;
        }

        .toggle-info .toggle-subtitle {
            font-size: 13px;
            color: #6B7280;
            margin-top: 4px;
        }

        .toggle-switch {
            position: relative;
            width: 56px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #D1D5DB;
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle-switch input:checked + .toggle-slider {
            background-color: #10B981;
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(28px);
        }

        /* Confirmation Popup Styles */
        .confirm-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(8px);
        }

        .confirm-modal {
            background: #FFFFFF;
            border-radius: 16px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 400px;
            padding: 32px;
            text-align: center;
        }

        .confirm-modal .icon {
            width: 48px;
            height: 48px;
            background: #FEF3C7;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
        }

        .confirm-modal .icon svg {
            width: 24px;
            height: 24px;
            color: #D97706;
        }

        .confirm-modal h3 {
            font-size: 18px;
            font-weight: 600;
            color: #1F2937;
            margin-bottom: 12px;
        }

        .confirm-modal p {
            color: #6B7280;
            line-height: 1.5;
            margin-bottom: 24px;
        }

        .confirm-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .confirm-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid;
            flex: 1;
        }

        .confirm-btn.cancel {
            background: #F9FAFB;
            border-color: #D1D5DB;
            color: #374151;
        }

        .confirm-btn.cancel:hover {
            background: #F3F4F6;
        }

        .confirm-btn.confirm {
            background: #DC2626;
            border-color: #DC2626;
            color: white;
        }

        .confirm-btn.confirm:hover {
            background: #B91C1C;
        }

        /* Task Group Header Styles */
        .task-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(90deg, #F9FAFB 0%, #F3F4F6 100%);
            border: 1px solid #E5E7EB;
            border-radius: 8px;
            padding: 10px 20px;
            margin: 0 20px 8px 20px;
            font-weight: 600;
            color: #374151;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .task-group-header.completed {
            background: linear-gradient(90deg, rgba(16, 185, 129, 0.1) 0%, rgba(5, 150, 105, 0.1) 100%);
            border-color: #10B981;
            color: #065F46;
        }

        .task-group-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .group-icon {
            font-size: 16px;
            flex-shrink: 0;
        }

        .task-group-progress {
            font-size: 12px;
            color: #6B7280;
            font-weight: 500;
            white-space: nowrap;
        }

        .task-group-header.completed .task-group-progress {
            color: #047857;
        }
        
        /* Hide native fullscreen button since it doesn't work in iframe */
        video::-webkit-media-controls-fullscreen-button {
            display: none !important;
        }
        video::-moz-media-controls-fullscreen-button {
            display: none !important;
        }
        video::-ms-media-controls-fullscreen-button {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Streak Counter -->
    <div class="streak-counter" id="streakCounter" style="display: none;">
        <span class="streak-icon">ðŸ”¥</span>
        <span id="streakText">0 day streak!</span>
    </div>

    <!-- Confetti Container -->
    <div class="confetti-container" id="confettiContainer"></div>

    <!-- Milestone Notification -->
    <div class="milestone-notification" id="milestoneNotification">
        <h3 id="milestoneTitle">Achievement Unlocked!</h3>
        <p id="milestoneMessage">Keep up the great work!</p>
    </div>

    <!-- Top Navigation Bar -->
    <nav class="top-navbar">
        <div class="nav-container">
            <div class="nav-left">
                <button class="menu-toggle" id="menuToggle" onclick="toggleTaskPanel()" title="Toggle tasks panel">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12h18M3 6h18M3 18h18"/>
                    </svg>
                </button>
                <div class="brand">
                    <h2>DFY CRM Onboarding</h2>
                </div>
            </div>
            <div class="nav-center">
                <div class="progress-indicator">
                    <div class="progress-bar-horizontal">
                        <div class="progress-fill-horizontal" id="progressFill"></div>
                    </div>
                    <span class="progress-text" id="progressText">0% Complete</span>
                    <div class="streak-counter" id="streakCounter" style="display: none;">
                        <span class="streak-icon">ðŸ”¥</span>
                        <span class="streak-text" id="streakText">0 Day Streak</span>
                    </div>
                </div>
            </div>
            <div class="nav-right">
                <div class="user-menu" id="userMenu">
                    <button class="user-menu-btn" onclick="toggleUserDropdown()">
                        <div class="user-avatar" id="userAvatar">
                            <span id="userInitials">?</span>
                        </div>
                        <span class="user-name" id="userName">Guest</span>
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                        </svg>
                    </button>
                    <div class="user-dropdown" id="userDropdown">
                        <div class="dropdown-header">
                            <div class="dropdown-user-info">
                                <div id="dropdownUserName">Guest</div>
                                <div id="dropdownUserEmail">Not logged in</div>
                                <div id="dropdownCompany"></div>
                            </div>
                        </div>
                        <div class="dropdown-divider"></div>
                        <button class="dropdown-item" onclick="openEditProfileModal()">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
                            </svg>
                            Edit Profile
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <div class="main-container" id="mainContainer">
        <!-- Task Panel (Left Sidebar) -->
        <aside class="task-panel" id="taskPanel">
            <div class="panel-header">
                <h3 id="taskPanelTitle">All Tasks</h3>
                <button class="panel-close" onclick="toggleTaskPanel()">Ã—</button>
            </div>
            <div class="task-controls">
                <select id="taskFilter" class="task-filter-dropdown" onchange="filterTasks()">
                    <option value="open">Open Tasks</option>
                    <option value="completed">Completed Tasks</option>
                    <option value="all">All Tasks</option>
                </select>
                <div class="search-container">
                    <input type="text" id="taskSearch" class="task-search-input" placeholder="Search tasks..." oninput="searchTasks()">
                    <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                </div>
            </div>
            <div class="task-list-container">
                <div id="taskList" class="task-list">
                    <div class="loading">Loading your onboarding tasks...</div>
                </div>
            </div>
        </aside>

        <!-- Instructions Panel -->
        <div class="instructions-panel" id="instructionsPanel">
            <div class="empty-state" id="emptyState">
                <h2>Welcome to Your Onboarding</h2>
                <p>Select a task from the left panel to get started</p>
            </div>
            <button class="close-btn" onclick="closeInstructions()" style="display: none;">&times;</button>
            <div class="instructions-content" id="instructionsContent" style="display: none;">
                <!-- Instructions will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Profile Completion Popup -->
    <div id="profileOverlay" class="profile-overlay" style="display: none;">
        <div class="profile-modal">
            <h2>Complete Your Profile</h2>
            <p class="subtitle">Before accessing your onboarding tasks, we need to collect some additional information to personalize your experience.</p>
            
            <form id="profileForm">
                <div class="profile-form-row">
                    <div class="profile-form-group">
                        <label for="firstName">First Name <span class="required">*</span></label>
                        <input type="text" id="firstName" name="firstName" required>
                    </div>
                    <div class="profile-form-group">
                        <label for="lastName">Last Name <span class="required">*</span></label>
                        <input type="text" id="lastName" name="lastName" required>
                    </div>
                </div>
                
                <div class="profile-form-group">
                    <label for="cellPhone">Cell Phone <span class="required">*</span></label>
                    <input type="tel" id="cellPhone" name="cellPhone" placeholder="(555) 123-4567" required>
                </div>
                
                <div class="profile-form-group">
                    <label for="companyName">Company Name <span class="required">*</span></label>
                    <input type="text" id="companyName" name="companyName" required>
                </div>
                
                <button type="submit" class="profile-submit-btn">
                    Complete Profile & Continue
                </button>
            </form>
        </div>
    </div>

    <!-- Edit Profile Modal -->
    <div id="editProfileOverlay" class="edit-profile-overlay" style="display: none;">
        <div class="edit-profile-modal">
            <h2>Edit Profile</h2>
            <p class="subtitle">Update your profile information below.</p>
            
            <form id="editProfileForm">
                <div class="profile-form-row">
                    <div class="profile-form-group">
                        <label for="editFirstName">First Name <span class="required">*</span></label>
                        <input type="text" id="editFirstName" name="firstName" required>
                    </div>
                    <div class="profile-form-group">
                        <label for="editLastName">Last Name <span class="required">*</span></label>
                        <input type="text" id="editLastName" name="lastName" required>
                    </div>
                </div>
                
                <div class="profile-form-group">
                    <label for="editCellPhone">Cell Phone <span class="required">*</span></label>
                    <input type="tel" id="editCellPhone" name="cellPhone" placeholder="(555) 123-4567" required>
                </div>
                
                <div class="profile-form-group">
                    <label for="editCompanyName">Company Name <span class="required">*</span></label>
                    <input type="text" id="editCompanyName" name="companyName" required>
                </div>
                
                <div class="profile-form-group">
                    <label for="editEmail" class="readonly-label">Email Address (cannot be changed)</label>
                    <input type="email" id="editEmail" name="email" class="readonly-field" readonly>
                </div>
                
                <div class="profile-form-group">
                    <label for="editLocationId" class="readonly-label">Location ID (cannot be changed)</label>
                    <input type="text" id="editLocationId" name="locationId" class="readonly-field" readonly>
                </div>
                
                <div class="toggle-group">
                    <div class="toggle-info">
                        <label>Task Notifications</label>
                        <div class="toggle-subtitle">Receive notifications for new tasks and reminders</div>
                    </div>
                    <div class="toggle-switch" onclick="handleNotificationToggleClick(event)">
                        <input type="checkbox" id="notificationsToggle" checked>
                        <span class="toggle-slider"></span>
                    </div>
                </div>
                
                <div style="display: flex; gap: 12px; margin-top: 8px;">
                    <button type="button" class="profile-submit-btn" onclick="closeEditProfileModal()" style="background: #6B7280;">
                        Cancel
                    </button>
                    <button type="submit" class="profile-submit-btn">
                        Update Profile
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Notification Opt-out Confirmation Modal -->
    <div id="confirmOptOutOverlay" class="confirm-overlay" style="display: none;">
        <div class="confirm-modal">
            <div class="icon">
                <svg viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
            </div>
            <h3>Turn Off Task Notifications?</h3>
            <p>You'll no longer receive notifications about new tasks, reminders, or updates. You can turn this back on anytime in your profile settings.</p>
            <div class="confirm-buttons">
                <button class="confirm-btn cancel" onclick="cancelOptOut()">Keep Notifications</button>
                <button class="confirm-btn confirm" onclick="confirmOptOut()">Turn Off</button>
            </div>
        </div>
    </div>

    <!-- Task Completion Confirmation Modal -->
    <div id="taskCompleteOverlay" class="confirm-overlay" style="display: none;">
        <div class="confirm-modal">
            <div class="icon" style="background: #D1FAE5;">
                <svg viewBox="0 0 24 24" fill="#059669">
                    <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
                </svg>
            </div>
            <h3 id="taskCompleteTitle">Complete Task?</h3>
            <p id="taskCompleteMessage">This task will be marked as completed. You can view completed tasks anytime by changing the filter to "Completed Tasks".</p>
            <div class="confirm-buttons">
                <button class="confirm-btn cancel" onclick="cancelTaskComplete()">Cancel</button>
                <button class="confirm-btn confirm" style="background: #059669; border-color: #059669;" onclick="confirmTaskComplete()">Mark Complete</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables - declared once
        const SUPABASE_URL = 'https://vvtzalcisnpibnlunqgn.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ2dHphbGNpc25waWJubHVucWduIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU5NTk4MzMsImV4cCI6MjA3MTUzNTgzM30.LJqY5AjAuwH5k65XY9cxfuqiuNNtjYo5k210IAg0PCk';
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        let currentUser = null;
        let currentChecklist = [];
        let taskInstructions = {};
        let currentStreak = 0;
        let lastCompletionDate = null;
        let completionSounds = [];
        
        let highLevelEnvironment = {
            baseUrl: null,
            locationId: null,
            fullUrl: null,
            detected: false
        };

        // Fallback tasks in case database is empty
        const fallbackTasks = [
            {
                task_id: 'profile',
                title: 'Complete Your Business Profile',
                description: 'Set up your company information and branding',
                instruction_title: 'Complete Your Business Profile',
                instruction_content: '<h2>Set Up Your Business Profile</h2><p>Your profile is the foundation of your DFY CRM experience. Complete these essential steps:</p><ul><li>Add your business name and description</li><li>Upload your company logo and branding</li><li>Set your contact information and address</li><li>Configure your business hours and timezone</li><li>Add your team members and roles</li></ul>',
                video_url: null,
                position: 1
            },
            {
                task_id: 'integration',
                title: 'Connect Your Essential Tools',
                description: 'Integrate your existing business systems',
                instruction_title: 'Connect Your Essential Tools',
                instruction_content: '<h2>Connect Your Tools</h2><p>Streamline your workflow by connecting your existing business tools:</p><ul><li>Connect your email marketing platform</li><li>Integrate your calendar and scheduling system</li><li>Set up payment processing and invoicing</li><li>Import your existing contacts and leads</li><li>Connect your phone system for call tracking</li></ul>',
                video_url: null,
                position: 2
            },
            {
                task_id: 'campaign',
                title: 'Launch Your First Automation',
                description: 'Create your initial lead nurture sequence',
                instruction_title: 'Launch Your First Automation',
                instruction_content: '<h2>Launch Your First Automation</h2><p>Get started with powerful marketing automation to grow your business:</p><ul><li>Choose your automation template</li><li>Define your target audience and triggers</li><li>Customize your messaging and content</li><li>Set up follow-up sequences and workflows</li><li>Test and activate your automation</li></ul>',
                video_url: null,
                position: 3
            }
        ];

        // Filter tasks based on user targeting
        function filterTasksForUser(tasks, user) {
            return tasks.filter(task => {
                const targetType = task.target_type;
                
                // Tasks must have a target type
                if (!targetType) {
                    return false;
                }
                
                // Group-based targeting
                if (targetType === 'groups') {
                    const taskGroups = Array.isArray(task.target_groups) ? task.target_groups : [];
                    
                    // User can have either user_groups array or user_group_id
                    let userGroupIds = [];
                    if (user.user_group_id) {
                        // Single group ID
                        userGroupIds = [String(user.user_group_id)];
                    }
                    if (Array.isArray(user.user_groups) && user.user_groups.length > 0) {
                        // Array of groups (legacy support)
                        userGroupIds = user.user_groups.map(g => String(g));
                    }
                    
                    // Check if user belongs to any of the target groups
                    // Convert both to strings for comparison to handle type mismatches
                    const taskGroupStrings = taskGroups.map(g => String(g));
                    const hasMatchingGroup = taskGroupStrings.some(groupId => userGroupIds.includes(groupId));
                    
                    return hasMatchingGroup;
                }
                
                // Location-based targeting
                if (targetType === 'locations') {
                    const taskLocations = Array.isArray(task.target_locations) ? task.target_locations : [];
                    
                    // Check if user's location matches any target locations
                    const hasMatchingLocation = taskLocations.includes(user.location_id);
                    
                    return hasMatchingLocation;
                }
                
                // Individual user targeting
                if (targetType === 'individuals') {
                    const targetUsers = Array.isArray(task.target_users) ? task.target_users : [];
                    
                    // Check if user's ID matches any target users
                    const hasMatchingUser = targetUsers.includes(user.id);
                    
                    return hasMatchingUser;
                }
                
                // Default fallback - show task
                return true;
            });
        }

        // Get URL parameters (case insensitive)
        function getUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Helper function to get parameter case-insensitively
            function getParamCaseInsensitive(paramName) {
                for (const [key, value] of urlParams) {
                    if (key.toLowerCase() === paramName.toLowerCase()) {
                        return value;
                    }
                }
                return null;
            }
            
            return {
                email: getParamCaseInsensitive('email'),
                locationId: getParamCaseInsensitive('locationId'),
                group: getParamCaseInsensitive('group')
            };
        }

        // Send webhook notification for task completion
        async function sendWebhook(taskData) {
            try {
                // Get task completion webhook URL from database
                let webhookUrl = null;
                try {
                    const { data, error } = await supabaseClient
                        .from('webhook_settings')
                        .select('webhook_url')
                        .eq('webhook_name', 'task_completion')
                        .eq('is_active', true)
                        .single();
                        
                    if (error || !data) {
                        console.warn('No active task_completion webhook found in database');
                        return;
                    }
                    
                    webhookUrl = data.webhook_url;
                } catch (error) {
                    console.error('Failed to get task completion webhook URL:', error);
                    return;
                }
                
                console.log('Sending webhook for task completion:', taskData);
                
                const webhookPayload = {
                    event: 'task_completion',
                    user_email: taskData.userEmail,
                    location_id: taskData.locationId,
                    task_id: taskData.taskId,
                    task_title: taskData.taskTitle,
                    completed: taskData.completed,
                    completed_at: taskData.completedAt,
                    timestamp: new Date().toISOString(),
                    // Include user profile information
                    firstName: taskData.firstName || '',
                    lastName: taskData.lastName || '',
                    cellPhone: taskData.cellPhone || '',
                    companyName: taskData.companyName || '',
                    fullName: taskData.fullName || taskData.userEmail
                };

                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(webhookPayload)
                });

                if (response.ok) {
                    console.log('Webhook sent successfully');
                } else {
                    console.error('Webhook failed with status:', response.status);
                }
            } catch (error) {
                console.error('Error sending webhook:', error);
                // Don't throw error - webhook failures shouldn't break the user experience
            }
        }

        // Load tasks from database with group-based sequencing
        async function loadTasks() {
            try {
                console.log('Loading tasks and task groups from database...');
                
                // Load all active tasks with their task groups
                const { data: tasks, error: tasksError } = await supabaseClient
                    .from('onboarding_tasks')
                    .select(`
                        *,
                        task_groups!task_group_id (
                            id,
                            group_name,
                            display_order,
                            is_active
                        )
                    `)
                    .eq('is_active', true)
                    .order('position');

                if (tasksError) {
                    console.error('Tasks database error:', tasksError);
                    throw tasksError;
                }

                // Load task group sequences
                const { data: sequences, error: sequencesError } = await supabaseClient
                    .from('task_group_sequences')
                    .select('*')
                    .eq('is_active', true);

                if (sequencesError) {
                    console.error('Sequences database error:', sequencesError);
                    // Don't throw - sequences are optional
                }

                console.log('Tasks loaded:', tasks?.length || 0);
                console.log('Sequences loaded:', sequences?.length || 0);

                // Use fallback if no tasks in database
                let activeTasks = (tasks && tasks.length > 0) ? tasks : fallbackTasks;
                
                // Filter tasks based on targeting
                activeTasks = filterTasksForUser(activeTasks, currentUser);
                
                console.log('Active tasks after filtering:', activeTasks.length);
                
                // Apply group-based sequencing
                activeTasks = await applyGroupSequencing(activeTasks, sequences || []);
                
                // Build task instructions object
                taskInstructions = {};
                activeTasks.forEach(task => {
                    taskInstructions[task.task_id] = {
                        title: task.instruction_title,
                        content: task.instruction_content,
                        video_url: task.video_url,
                        video_type: task.video_type,
                        form_embed_code: task.form_embed_code,
                        groupInfo: task.task_groups ? {
                            id: task.task_groups.id,
                            name: task.task_groups.group_name,
                            display_order: task.task_groups.display_order
                        } : null
                    };
                });

                return activeTasks;
            } catch (error) {
                console.error('Error loading tasks:', error);
                return fallbackTasks;
            }
        }

        // Apply group-based sequencing logic
        async function applyGroupSequencing(tasks, sequences) {
            if (!sequences || sequences.length === 0) {
                console.log('No sequences configured, showing all tasks');
                return tasks;
            }
            
            console.log('Applying group sequencing...');
            
            // Group tasks by task_group_id
            const tasksByGroup = {};
            const unassignedTasks = [];
            
            tasks.forEach(task => {
                if (task.task_group_id && task.task_groups) {
                    const groupId = task.task_group_id;
                    if (!tasksByGroup[groupId]) {
                        tasksByGroup[groupId] = [];
                    }
                    tasksByGroup[groupId].push(task);
                } else {
                    // Tasks without groups are always visible
                    unassignedTasks.push(task);
                }
            });
            
            // Determine which groups should be visible
            const visibleGroups = new Set();
            const lockedGroups = new Set();
            
            // Check sequences to determine which groups should be locked/unlocked
            for (const sequence of sequences) {
                // Check if sequence applies to this user
                if (!sequenceAppliesToUser(sequence, currentUser)) {
                    continue;
                }
                
                const prerequisiteGroupId = sequence.prerequisite_group_id;
                const unlockGroupId = sequence.unlock_group_id;
                
                // Check if prerequisite group is completed
                const prerequisiteGroupCompleted = await isGroupCompleted(prerequisiteGroupId, tasksByGroup);
                
                if (prerequisiteGroupCompleted) {
                    console.log(`Prerequisite group ${prerequisiteGroupId} completed, unlocking group ${unlockGroupId}`);
                    visibleGroups.add(unlockGroupId);
                } else {
                    console.log(`Prerequisite group ${prerequisiteGroupId} not completed, locking group ${unlockGroupId}`);
                    lockedGroups.add(unlockGroupId);
                }
                
                // Always show prerequisite group
                visibleGroups.add(prerequisiteGroupId);
            }
            
            // Remove locked groups from visible groups
            lockedGroups.forEach(groupId => {
                visibleGroups.delete(groupId);
            });
            
            // Collect visible tasks
            let visibleTasks = [...unassignedTasks]; // Always include unassigned tasks
            
            // Add tasks from visible groups
            visibleGroups.forEach(groupId => {
                if (tasksByGroup[groupId]) {
                    visibleTasks = visibleTasks.concat(tasksByGroup[groupId]);
                }
            });
            
            // Sort tasks by group display order, then by position
            visibleTasks.sort((a, b) => {
                const aGroupOrder = a.task_groups?.display_order || 0;
                const bGroupOrder = b.task_groups?.display_order || 0;
                
                if (aGroupOrder !== bGroupOrder) {
                    return aGroupOrder - bGroupOrder;
                }
                
                return (a.position || 0) - (b.position || 0);
            });
            
            console.log(`Showing ${visibleTasks.length} tasks after sequencing`);
            return visibleTasks;
        }
        
        // Check if sequence applies to current user
        function sequenceAppliesToUser(sequence, user) {
            const appliesTo = sequence.applies_to || 'all';
            
            if (appliesTo === 'all') {
                return true;
            }
            
            if (appliesTo === 'groups') {
                const sequenceGroups = Array.isArray(sequence.target_groups) ? sequence.target_groups : [];
                const userGroups = Array.isArray(user.user_groups) ? user.user_groups : [];
                return sequenceGroups.some(groupId => userGroups.includes(groupId));
            }
            
            if (appliesTo === 'locations') {
                const sequenceLocations = Array.isArray(sequence.target_locations) ? sequence.target_locations : [];
                return sequenceLocations.includes(user.location_id);
            }
            
            if (appliesTo === 'individuals') {
                const targetUsers = Array.isArray(sequence.target_users) ? sequence.target_users : [];
                return targetUsers.includes(user.id);
            }
            
            return true;
        }
        
        // Check if all tasks in a group are completed
        async function isGroupCompleted(groupId, tasksByGroup) {
            const groupTasks = tasksByGroup[groupId];
            if (!groupTasks || groupTasks.length === 0) {
                return true; // Empty group is considered completed
            }
            
            // Check user's current checklist for completion status
            const allCompleted = groupTasks.every(task => {
                const userTask = currentChecklist.find(ut => ut.id === task.task_id);
                return userTask && userTask.completed;
            });
            
            console.log(`Group ${groupId} completion status: ${allCompleted} (${groupTasks.length} tasks)`);
            return allCompleted;
        }

        // Convert group name to URL-friendly slug
        function createUrlSlug(groupName) {
            return groupName.toLowerCase()
                .replace(/\s+/g, '_')  // Replace spaces with underscores
                .replace(/[^a-z0-9_]/g, '');  // Remove special characters
        }
        
        // Find group by slug or name
        async function findGroupBySlug(groupSlug) {
            if (!groupSlug) return null;
            
            try {
                // First try to find by exact slug match
                const { data: groups, error } = await supabaseClient
                    .from('user_groups')
                    .select('*')
                    .eq('is_active', true);
                    
                if (error) {
                    console.error('Error fetching groups:', error);
                    return null;
                }
                
                console.log('Available groups:', groups?.map(g => g.group_name));
                console.log('Looking for group with slug:', groupSlug);
                
                // Look for matching group by multiple methods
                const matchingGroup = groups.find(group => {
                    // Try exact name match (case insensitive)
                    if (group.group_name.toLowerCase() === groupSlug.toLowerCase()) {
                        return true;
                    }
                    // Try slug match
                    if (createUrlSlug(group.group_name) === groupSlug.toLowerCase()) {
                        return true;
                    }
                    // Try removing spaces and special chars
                    const simplifiedName = group.group_name.toLowerCase().replace(/[^a-z0-9]/g, '');
                    const simplifiedSlug = groupSlug.toLowerCase().replace(/[^a-z0-9]/g, '');
                    if (simplifiedName === simplifiedSlug) {
                        return true;
                    }
                    return false;
                });
                
                if (matchingGroup) {
                    console.log('Found matching group:', matchingGroup);
                    return matchingGroup;
                }
                
                console.log('No matching group found for slug:', groupSlug);
                return null;
            } catch (error) {
                console.error('Error finding group:', error);
                return null;
            }
        }
        
        // Load or create user
        async function loadUser(email, locationId, groupSlug = null) {
            try {
                console.log('Loading user:', email, locationId);
                
                // Check if user exists
                const { data: existingUser, error: fetchError } = await supabaseClient
                    .from('onboarding_users')
                    .select('*')
                    .eq('email', email)
                    .eq('location_id', locationId)
                    .single();

                if (fetchError && fetchError.code !== 'PGRST116') {
                    console.error('Error fetching user:', fetchError);
                    throw fetchError;
                }

                if (existingUser) {
                    console.log('Existing user found:', existingUser);
                    console.log('User profile data:', {
                        first_name: existingUser.first_name,
                        last_name: existingUser.last_name,
                        cell_phone: existingUser.cell_phone,
                        company_name: existingUser.company_name,
                        profile_completed: existingUser.profile_completed
                    });
                    
                    // ALWAYS update user's group based on URL parameter
                    // This ensures users are automatically moved to new groups when URL changes
                    if (groupSlug) {
                        const newGroup = await findGroupBySlug(groupSlug);
                        if (newGroup) {
                            if (newGroup.id !== existingUser.user_group_id) {
                                console.log('User group changed from', existingUser.user_group_id, 'to', newGroup.id);
                                
                                // Load tasks for the new group
                                const tasks = await loadTasks();
                                
                                // Get all task groups that belong to this user group
                                const { data: taskGroups, error: taskGroupsError } = await supabaseClient
                                    .from('task_groups')
                                    .select('id')
                                    .eq('user_group_id', newGroup.id)
                                    .eq('is_active', true);
                                
                                if (taskGroupsError) {
                                    console.error('Error fetching task groups:', taskGroupsError);
                                }
                                
                                const taskGroupIds = taskGroups ? taskGroups.map(tg => tg.id) : [];
                                console.log('Task groups for user group', newGroup.id, ':', taskGroupIds);
                                
                                // Create new checklist for the new group
                                const newChecklist = tasks
                                    .filter(task => {
                                        // Include tasks that belong to task groups of this user group
                                        return task.task_group_id && taskGroupIds.includes(task.task_group_id);
                                    })
                                    .map(task => ({
                                        id: task.task_id,
                                        completed: false  // Reset all tasks to incomplete for new group
                                    }));
                                
                                console.log('Resetting checklist for new group with', newChecklist.length, 'tasks');
                                
                                // Update user's group and reset checklist
                                const { error: updateError } = await supabaseClient
                                    .from('onboarding_users')
                                    .update({ 
                                        user_group_id: newGroup.id,
                                        checklist: newChecklist,
                                        completed_tasks: [],  // Clear completed tasks
                                        updated_at: new Date().toISOString()
                                    })
                                    .eq('id', existingUser.id);
                                
                                if (updateError) {
                                    console.error('Error updating user group:', updateError);
                                } else {
                                    existingUser.user_group_id = newGroup.id;
                                    existingUser.checklist = newChecklist;
                                    existingUser.completed_tasks = [];
                                    console.log('User group and checklist updated successfully');
                                }
                            } else {
                                console.log('User already in group:', newGroup.group_name);
                            }
                        } else {
                            console.error('Invalid group slug:', groupSlug);
                            showError('Invalid group specified in URL. Please contact support@dfycrm.com');
                        }
                    }
                    
                    // Check if profile is completed
                    if (!existingUser.profile_completed) {
                        console.log('Profile not completed, showing profile popup');
                        showProfilePopup(existingUser);
                        return existingUser;
                    }
                    
                    return existingUser;
                }

                // Create new user
                console.log('Creating new user...');
                
                // Find the group to assign (group is now mandatory)
                const groupToAssign = await findGroupBySlug(groupSlug);
                console.log('Group to assign:', groupToAssign);
                
                if (!groupToAssign) {
                    console.log('No valid group found for parameter:', groupSlug);
                    showError('Invalid group specified. Please contact support@dfycrm.com for assistance.');
                    
                    // Check if app element exists before setting innerHTML
                    const appElement = document.getElementById('app');
                    if (appElement) {
                        appElement.innerHTML = `
                            <div style="text-align: center; padding: 50px; background: #FEE2E2; border-radius: 8px; margin: 20px;">
                                <h2 style="color: #DC2626; margin-bottom: 20px;">Invalid Group</h2>
                                <p style="color: #7F1D1D; font-size: 18px; margin-bottom: 20px;">
                                    The group "${groupSlug}" is not valid or does not exist in the system.
                                </p>
                                <p style="color: #6B7280; background: #F3F4F6; padding: 12px; border-radius: 6px; margin: 20px 0;">
                                    Please ensure a user group named "<strong>DFY</strong>" exists in the admin panel.
                                </p>
                                <p style="color: #7F1D1D; margin-bottom: 30px;">
                                    Contact support for assistance:
                                </p>
                                <a href="mailto:support@dfycrm.com" style="
                                    display: inline-block;
                                    background: #DC2626;
                                    color: white;
                                    padding: 12px 30px;
                                    border-radius: 8px;
                                    text-decoration: none;
                                    font-weight: bold;
                                    font-size: 16px;
                                ">support@dfycrm.com</a>
                            </div>
                        `;
                    } else {
                        console.error('App element not found in DOM');
                    }
                    return;
                }
                
                const tasks = await loadTasks();
                const initialChecklist = tasks.map(task => ({
                    id: task.task_id,
                    title: task.task_title || task.title || '',
                    description: task.task_description || task.description || '',
                    completed: false
                }));

                const { data: newUser, error: createError } = await supabaseClient
                    .from('onboarding_users')
                    .insert([{
                        email: email,
                        location_id: locationId,
                        checklist: initialChecklist,
                        profile_completed: false,
                        user_group_id: groupToAssign ? groupToAssign.id : null
                    }])
                    .select()
                    .single();

                if (createError) {
                    console.error('Error creating user:', createError);
                    throw createError;
                }

                console.log('New user created:', newUser);
                
                // New users always need to complete profile
                console.log('New user needs to complete profile');
                showProfilePopup(newUser);
                
                return newUser;
            } catch (error) {
                console.error('Error in loadUser:', error);
                throw error;
            }
        }

        // Detect HighLevel Environment
        function detectHighLevelEnvironment() {
            try {
                let parentUrl = null;
                
                // Try to get parent window URL
                if (window.parent && window.parent !== window) {
                    try {
                        parentUrl = window.parent.location.href;
                    } catch (e) {
                        console.log('Cross-origin restriction, trying alternative detection...');
                    }
                }
                
                // Fallback: Check referrer
                if (!parentUrl && document.referrer) {
                    parentUrl = document.referrer;
                }
                
                // Fallback: Check current URL
                if (!parentUrl && window.location.href.includes('/location/')) {
                    parentUrl = window.location.href;
                }
                
                
                if (parentUrl) {
                    // Parse HighLevel URL structure
                    const urlMatch = parentUrl.match(/^(https?:\/\/[^\/]+).*\/location\/([a-zA-Z0-9]+)/);
                    if (urlMatch) {
                        highLevelEnvironment.baseUrl = urlMatch[1];
                        highLevelEnvironment.locationId = urlMatch[2];
                        highLevelEnvironment.fullUrl = parentUrl;
                        highLevelEnvironment.detected = true;
                        
                        console.log('HighLevel environment detected:', highLevelEnvironment);
                        
                        
                        return true;
                    }
                }
                
                return false;
            } catch (error) {
                console.error('Error detecting HighLevel environment:', error);
                return false;
            }
        }
        
        
        
        
        
        
        // Show notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
                color: white;
                padding: 16px 24px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                z-index: 10000;
                max-width: 400px;
                animation: slideIn 0.3s ease-out;
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 5000);
        }
        
        // Update user checklist
        async function updateUserChecklist(checklist) {
            try {
                console.log('Updating user checklist...');
                const { error } = await supabaseClient
                    .from('onboarding_users')
                    .update({ 
                        checklist: checklist,
                        updated_at: new Date().toISOString()
                    })
                    .eq('email', currentUser.email)
                    .eq('location_id', currentUser.location_id);

                if (error) {
                    console.error('Error updating checklist:', error);
                    throw error;
                }

                console.log('Checklist updated successfully');
                currentChecklist = checklist;
                updateProgress();
            } catch (error) {
                console.error('Error updating user checklist:', error);
                showError('Failed to save progress. Please try again.');
            }
        }

        // Get progress data for webhook
        function getProgressData(taskId) {
            // Find the task being toggled and its group
            const taskDetails = taskInstructions[taskId];
            const currentTaskGroup = taskDetails?.groupInfo || null;
            
            // Calculate overall progress
            const totalTasks = currentChecklist.length;
            const completedTasks = currentChecklist.filter(t => t.completed).length;
            const overallProgress = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
            
            // Calculate group progress if task belongs to a group
            let groupProgress = null;
            let groupCompletedTasks = 0;
            let groupTotalTasks = 0;
            
            if (currentTaskGroup) {
                // Get all tasks in the same group
                const tasksInGroup = currentChecklist.filter(t => {
                    const taskInfo = taskInstructions[t.id];
                    return taskInfo?.groupInfo?.id === currentTaskGroup.id;
                });
                
                groupTotalTasks = tasksInGroup.length;
                groupCompletedTasks = tasksInGroup.filter(t => t.completed).length;
                groupProgress = groupTotalTasks > 0 ? Math.round((groupCompletedTasks / groupTotalTasks) * 100) : 0;
            }
            
            // Get user's group information
            const userGroup = currentUser?.user_group_id ? {
                id: currentUser.user_group_id,
                name: currentUser.user_group_name || 'Unknown Group'
            } : null;
            
            return {
                userGroup: userGroup,
                currentTaskGroup: currentTaskGroup ? {
                    id: currentTaskGroup.id,
                    name: currentTaskGroup.name,
                    displayOrder: currentTaskGroup.display_order
                } : null,
                groupProgress: {
                    completed: groupCompletedTasks,
                    total: groupTotalTasks,
                    percentage: groupProgress
                },
                overallProgress: {
                    completed: completedTasks,
                    total: totalTasks,
                    percentage: overallProgress
                }
            };
        }
        
        // Toggle task completion
        let pendingTaskComplete = null;
        
        async function toggleTask(taskId, completed) {
            console.log('Toggling task:', taskId, completed);
            
            // Find the task being toggled
            const task = currentChecklist.find(t => t.id === taskId);
            if (!task) {
                console.error('Task not found:', taskId);
                return;
            }
            
            // If completing a task, check video requirement
            if (completed) {
                // Check if video completion is required
                if (task.require_video_completion && videoProgressTracker) {
                    const isVideoCompleted = await videoProgressTracker.isVideoCompleted(taskId);
                    if (!isVideoCompleted) {
                        const progress = await videoProgressTracker.getProgress(taskId);
                        const percentage = progress?.watch_percentage || 0;
                        
                        alert(`Please complete the video before marking this task as complete.\n\nVideo progress: ${Math.round(percentage)}% (95% required)`);
                        
                        // Reset checkbox
                        const checkbox = document.querySelector(`input[type="checkbox"][onclick*="${taskId}"]`);
                        if (checkbox) checkbox.checked = false;
                        
                        // Reset complete buttons
                        const completeButtons = document.querySelectorAll('.header-complete-btn, .complete-task-btn');
                        completeButtons.forEach(btn => {
                            if (btn.dataset.taskId === taskId) {
                                btn.textContent = btn.textContent.includes('Complete Task') ? 'âœ“ Complete Task' : 'âœ“ Complete';
                            }
                        });
                        
                        return;
                    }
                }
                
                pendingTaskComplete = { taskId, task };
                document.getElementById('taskCompleteTitle').textContent = 'Complete Task?';
                document.getElementById('taskCompleteMessage').textContent = 
                    `Mark "${task.title}" as completed? You can view completed tasks anytime by changing the filter to "Completed Tasks".`;
                document.getElementById('taskCompleteOverlay').style.display = 'flex';
                return;
            }
            
            // If uncompleting, do it immediately
            await performTaskToggle(taskId, completed);
        }
        
        async function performTaskToggle(taskId, completed) {
            // Find the task being toggled
            const task = currentChecklist.find(t => t.id === taskId);
            if (!task) return;
            
            const updatedChecklist = currentChecklist.map(t => {
                if (t.id === taskId) {
                    return { ...t, completed: completed };
                }
                return t;
            });

            await updateUserChecklist(updatedChecklist);
            renderTasks();

            // Trigger celebration if task was completed (not uncompleted)
            if (completed) {
                celebrateCompletion();
            }

            // Send webhook notification
            const params = getUrlParams();
            if (params.email && params.locationId) {
                // Get progress data for the webhook
                const progressData = getProgressData(taskId);
                
                // Debug: Log currentUser and progress data
                console.log('Current user data for webhook:', currentUser);
                console.log('Progress data for webhook:', progressData);
                
                await sendWebhook({
                    userEmail: params.email,
                    locationId: params.locationId,
                    taskId: taskId,
                    taskTitle: task.title,
                    completed: completed,
                    completedAt: new Date().toISOString(),
                    dueDate: task.due_date || null, // Include task due date if it exists
                    // Include user profile information
                    firstName: currentUser?.first_name || '',
                    lastName: currentUser?.last_name || '',
                    cellPhone: currentUser?.cell_phone || '',
                    companyName: currentUser?.company_name || '',
                    fullName: [currentUser?.first_name, currentUser?.last_name].filter(n => n).join(' ') || params.email,
                    // Include group and progress information
                    userGroup: progressData.userGroup,
                    currentTaskGroup: progressData.currentTaskGroup,
                    groupProgress: progressData.groupProgress,
                    overallProgress: progressData.overallProgress
                });
            }
        }

        // Current filter state
        let currentFilter = 'open';
        let currentSearchTerm = '';
        
        // Filter tasks based on dropdown selection
        function filterTasks() {
            const filterValue = document.getElementById('taskFilter').value;
            currentFilter = filterValue;
            renderTasks();
        }
        
        // Search tasks based on input
        function searchTasks() {
            const searchTerm = document.getElementById('taskSearch').value.toLowerCase();
            currentSearchTerm = searchTerm;
            renderTasks();
        }
        
        // Render tasks with group headers
        function renderTasks() {
            const taskList = document.getElementById('taskList');
            
            if (currentChecklist.length === 0) {
                taskList.innerHTML = '<div class="error">No tasks found. Please contact support.</div>';
                return;
            }
            
            // Filter tasks based on current filter and search
            let filteredTasks = currentChecklist.filter(task => {
                // Apply status filter
                if (currentFilter === 'open' && task.completed) return false;
                if (currentFilter === 'completed' && !task.completed) return false;
                
                // Apply search filter
                if (currentSearchTerm) {
                    const searchableText = `${task.title} ${task.description}`.toLowerCase();
                    if (!searchableText.includes(currentSearchTerm)) return false;
                }
                
                return true;
            });
            
            if (filteredTasks.length === 0) {
                const filterText = currentFilter === 'open' ? 'open' : currentFilter === 'completed' ? 'completed' : '';
                const searchText = currentSearchTerm ? ` matching "${currentSearchTerm}"` : '';
                taskList.innerHTML = `<div style="text-align: center; padding: 40px; color: #6B7280;">No ${filterText} tasks found${searchText}.</div>`;
                return;
            }

            // Group tasks by their task group
            const taskGroups = {};
            const ungroupedTasks = [];
            
            filteredTasks.forEach(task => {
                const groupInfo = getTaskGroupInfo(task.id);
                if (groupInfo) {
                    const groupKey = `${groupInfo.id}_${groupInfo.name}`;
                    if (!taskGroups[groupKey]) {
                        taskGroups[groupKey] = {
                            info: groupInfo,
                            tasks: []
                        };
                    }
                    taskGroups[groupKey].tasks.push(task);
                } else {
                    ungroupedTasks.push(task);
                }
            });

            let html = '';
            
            // Sort and render grouped tasks first
            Object.values(taskGroups)
                .sort((a, b) => (a.info.display_order || 0) - (b.info.display_order || 0))
                .forEach(group => {
                    // Simply render all tasks in this group without the header
                    html += group.tasks.map(task => renderTaskItem(task)).join('');
                });
            
            // Render ungrouped tasks last (without a header)
            if (ungroupedTasks.length > 0) {
                html += ungroupedTasks.map(task => renderTaskItem(task)).join('');
            }

            taskList.innerHTML = html;
            updateProgress();
        }
        
        // Render individual task item
        function renderTaskItem(task) {
            const isCurrentTask = currentOpenTaskId === task.id;
            return `
                <div class="task-item ${task.completed ? 'completed' : ''} ${isCurrentTask ? 'current' : ''}" onclick="showInstructions('${task.id}')">
                    <div class="task-content">
                        <div class="task-checkbox ${task.completed ? 'checked' : ''}" 
                             onclick="event.stopPropagation(); toggleTask('${task.id}', ${!task.completed})"></div>
                        <div class="task-details">
                            <div class="task-title">${task.title}</div>
                            <div class="task-description">${task.description}</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Get task group information for a task
        function getTaskGroupInfo(taskId) {
            // Find the task in taskInstructions to get its group info
            for (const [id, instruction] of Object.entries(taskInstructions)) {
                if (id === taskId && instruction.groupInfo) {
                    return instruction.groupInfo;
                }
            }
            return null;
        }

        // Update progress bar
        function updateProgress() {
            const completed = currentChecklist.filter(task => task.completed).length;
            const total = currentChecklist.length;
            const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
            
            // Update horizontal progress bar in navbar
            document.getElementById('progressFill').style.width = percentage + '%';
            document.getElementById('progressText').textContent = `${percentage}% Complete`;
        }

        // Track currently open task to manage state
        let currentOpenTaskId = null;

        // Show instructions
        function showInstructions(taskId) {
            // taskId comes as string from onclick handlers, keep it as is for taskInstructions lookup
            const instructions = taskInstructions[taskId];
            if (!instructions) {
                console.error('No instructions found for task:', taskId);
                return;
            }

            // If this is the same task that's already open, do nothing
            if (currentOpenTaskId === taskId) {
                return;
            }

            // If a different task is open, close it first
            if (currentOpenTaskId && currentOpenTaskId !== taskId) {
                closeInstructions();
                // Small delay to ensure smooth transition
                setTimeout(() => {
                    showInstructionsContent(taskId, instructions);
                }, 100);
                return;
            }

            // Set the current open task
            currentOpenTaskId = taskId;
            showInstructionsContent(taskId, instructions);
        }

        // Clean Quill editor artifacts from content
        function cleanQuillContent(content) {
            if (!content) return '';
            
            let cleanedContent = content;
            
            // Remove Quill toolbar elements
            cleanedContent = cleanedContent.replace(/<div class="ql-toolbar[^>]*>[\s\S]*?<\/div>/gi, '');
            
            // Remove any toolbar-related elements but preserve iframes and embeds
            cleanedContent = cleanedContent.replace(/<span class="ql-[^"]*"[^>]*>[\s\S]*?<\/span>/gi, '');
            
            // Remove Quill editor containers but keep content
            cleanedContent = cleanedContent.replace(/<div class="ql-editor[^>]*>([\s\S]*?)<\/div>/gi, '$1');
            
            // Remove any other Quill-specific classes and elements
            cleanedContent = cleanedContent.replace(/class="ql-[^"]*"/gi, '');
            
            // DON'T remove divs that contain iframes or scripts (calendar embeds)
            cleanedContent = cleanedContent.replace(/<div[^>]*>(\s*)<\/div>/gi, (match, content) => {
                // Only remove truly empty divs
                if (!content || content.trim() === '') {
                    return '';
                }
                return match;
            });
            
            // Preserve calendar/booking scripts and iframes
            // Only remove scripts that are specifically Quill-related
            cleanedContent = cleanedContent.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, (match) => {
                // Remove only Quill-specific scripts
                if (match.includes('quill') || match.includes('ql-')) {
                    return '';
                }
                // Keep all other scripts (including calendar embeds)
                return match;
            });
            
            return cleanedContent.trim();
        }

        // Toggle video play/pause
        function toggleVideoPlay(taskId) {
            const video = document.getElementById(`task-video-${taskId}`);
            
            if (!video) return;
            
            if (video.paused) {
                video.play();
            } else {
                video.pause();
            }
        }
        
        // Setup video progress tracking
        function setupVideoProgress(taskId) {
            const video = document.getElementById(`task-video-${taskId}`);
            const progressBar = document.getElementById(`video-progress-${taskId}`);
            const timeDisplay = document.getElementById(`video-time-${taskId}`);
            
            if (!video) return;
            
            // Update progress bar
            video.addEventListener('timeupdate', function() {
                const progress = (video.currentTime / video.duration) * 100;
                if (progressBar) {
                    progressBar.style.width = progress + '%';
                }
                
                // Update time display
                if (timeDisplay) {
                    const currentTime = formatTime(video.currentTime);
                    const duration = formatTime(video.duration);
                    timeDisplay.textContent = `${currentTime} / ${duration}`;
                }
            });
            
            // Handle video ended
            video.addEventListener('ended', function() {
                const overlay = document.getElementById(`play-overlay-${taskId}`);
                if (overlay) {
                    overlay.classList.remove('hidden');
                }
            });
        }
        
        // Seek video on progress bar click
        function seekVideo(event, taskId) {
            event.stopPropagation();
            const video = document.getElementById(`task-video-${taskId}`);
            const progressBar = event.currentTarget;
            
            if (!video || !progressBar) return;
            
            const rect = progressBar.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            video.currentTime = pos * video.duration;
        }
        
        // Format time helper
        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Diagnostic function to check fullscreen availability
        function checkFullscreenSupport() {
            console.log('=== Fullscreen Diagnostic ===');
            console.log('Fullscreen enabled:', document.fullscreenEnabled);
            console.log('In iframe:', window.self !== window.top);
            console.log('Protocol:', window.location.protocol);
            
            const video = document.querySelector('video');
            if (video) {
                console.log('Video ready state:', video.readyState);
                console.log('Video network state:', video.networkState);
                console.log('Video source:', video.currentSrc || video.src);
                
                // Check if fullscreen API exists
                const hasAPI = !!(
                    video.requestFullscreen ||
                    video.webkitRequestFullscreen ||
                    video.mozRequestFullScreen ||
                    video.msRequestFullscreen
                );
                console.log('Fullscreen API available:', hasAPI);
            }
            
            // Check for video player frameworks
            console.log('=== Video Framework Detection ===');
            console.log('Video.js detected:', !!window.videojs);
            console.log('Plyr detected:', !!window.Plyr);
            console.log('JWPlayer detected:', !!window.jwplayer);
            console.log('MediaElement.js detected:', !!window.mejs);
        }
        
        // Make diagnostic function globally available
        window.checkFullscreenSupport = checkFullscreenSupport;
        
        // Robust video state preservation functions
        function preserveVideoStateRobustly(video, targetContainer) {
            // Save ALL relevant state
            const state = {
                currentTime: video.currentTime,
                paused: video.paused,
                playbackRate: video.playbackRate,
                volume: video.volume,
                muted: video.muted,
                src: video.src || video.currentSrc,
                poster: video.poster
            };
            
            console.log('Saving video state:', state);
            
            // Move the video
            targetContainer.appendChild(video);
            
            // Restore state after DOM settles
            requestAnimationFrame(() => {
                if (video.readyState >= 1) { // HAVE_METADATA
                    restoreVideoState(video, state);
                } else {
                    video.addEventListener('loadedmetadata', () => {
                        restoreVideoState(video, state);
                    }, { once: true });
                }
            });
            
            return state;
        }
        
        function restoreVideoState(video, state) {
            console.log('Restoring video state:', state);
            
            try {
                video.currentTime = state.currentTime;
                video.playbackRate = state.playbackRate;
                video.volume = state.volume;
                video.muted = state.muted;
                
                if (!state.paused) {
                    video.play().catch(e => console.log('Play failed:', e));
                }
                
                console.log('State restored. Current time now:', video.currentTime);
            } catch (e) {
                console.error('Failed to restore state:', e);
            }
        }
        
        // Video expansion using CSS modal (works in iframe environments)
        function expandVideo(taskId) {
            const video = document.getElementById(`task-video-${taskId}`);
            const container = document.getElementById(`video-container-${taskId}`);
            
            if (!video || !container) {
                console.error('Cannot expand video: Element not found');
                return;
            }
            
            // Store current state (only for video elements, not iframes)
            let currentTime = 0;
            let wasPlaying = false;
            if (video.tagName === 'VIDEO') {
                currentTime = video.currentTime;
                wasPlaying = !video.paused;
            }
            
            // Hide the overlay expand button if it exists
            const overlayBtn = container.querySelector('button[title*="Expand"]');
            if (overlayBtn) {
                overlayBtn.style.display = 'none';
            }
            
            // Create "Back to Instructions" button
            const backBtn = document.createElement('button');
            backBtn.textContent = 'â† Back to Instructions';
            backBtn.className = 'back-to-instructions';
            
            // Always use CSS expansion (no fullscreen API attempts)
            console.log('Using CSS modal for video expansion');
            useCSSExpansion(taskId, container, video, backBtn, overlayBtn, currentTime, wasPlaying);
        }
        
        // CSS-based in-place expansion (works in iframe environments)
        function useCSSExpansion(taskId, container, video, backBtn, overlayBtn, currentTime, wasPlaying) {
            
            console.log('=== IN-PLACE VIDEO EXPANSION ===');
            console.log('Video continues playing without interruption');
            
            // Store original styles to restore later
            const originalStyles = {
                container: container.getAttribute('style') || '',
                video: video.getAttribute('style') || '',
                scrollPosition: window.scrollY
            };
            
            // Create a dark background overlay
            const bgOverlay = document.createElement('div');
            bgOverlay.id = `bg-overlay-${taskId}`;
            bgOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: black;
                z-index: 99998;
            `;
            document.body.appendChild(bgOverlay);
            
            // Expand the container in place to cover the screen
            container.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                z-index: 99999 !important;
                background: black !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                margin: 0 !important;
                padding: 0 !important;
            `;
            
            // Expand the video to fill the container
            video.style.cssText = `
                width: 100% !important;
                height: 100% !important;
                object-fit: contain !important;
                max-width: 100vw !important;
                max-height: 100vh !important;
            `;
            
            // Update back button to work with in-place expansion
            backBtn.style.cssText = `
                position: fixed !important;
                top: 20px !important;
                left: 20px !important;
                z-index: 100001 !important;
                background: rgba(0,0,0,0.8) !important;
                color: white !important;
                border: 2px solid white !important;
                padding: 10px 20px !important;
                border-radius: 8px !important;
                cursor: pointer !important;
                font-size: 16px !important;
                display: block !important;
                visibility: visible !important;
            `;
            
            // Append back button to the body so it's always on top
            document.body.appendChild(backBtn);
            
            const exitExpanded = () => {
                console.log('=== EXITING IN-PLACE EXPANSION ===');
                
                // Restore original styles
                container.setAttribute('style', originalStyles.container);
                video.setAttribute('style', originalStyles.video);
                
                // Remove background overlay
                bgOverlay.remove();
                
                // Clean up
                backBtn.remove();
                if (overlayBtn) {
                    overlayBtn.style.display = '';
                }
                
                // Restore scroll position
                window.scrollTo(0, originalStyles.scrollPosition);
                
                console.log('Video continues playing at same position');
            };
            
            // Update back button click handler
            backBtn.onclick = exitExpanded;
            
            // Add escape key handler
            const escapeHandler = (e) => {
                if (e.key === 'Escape') {
                    exitExpanded();
                    document.removeEventListener('keydown', escapeHandler);
                }
            };
            document.addEventListener('keydown', escapeHandler);
            
            // No need for additional state restoration - clone already has the correct state
        }
        
        // Stub functions for compatibility
        function expandVideoCustom(taskId, task, videoElement) {
            expandVideo(taskId);
        }
        
        function exitExpandedVideo() {
            // Exit any CSS expanded overlays
            const overlays = document.querySelectorAll('[id^="expanded-overlay-"]');
            overlays.forEach(overlay => {
                // Find the back button and trigger its click
                const backBtn = overlay.querySelector('.back-to-instructions');
                if (backBtn) {
                    backBtn.click();
                }
            });
        }
        
        function exitFullscreenVideo() {
            exitExpandedVideo();
        }
        
        // Make functions globally accessible
        window.expandVideo = expandVideo;
        window.expandVideoCustom = expandVideoCustom;
        window.exitExpandedVideo = exitExpandedVideo;
        window.exitFullscreenVideo = exitFullscreenVideo;
        
        // NOTE: All old expansion code has been removed - using new simple approach above
        // Handle escape key to exit expanded video
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                exitExpandedVideo();
            }
        });
        
        // Navigate to previous/next task
        function navigateTask(direction) {
            const openTasks = currentChecklist.filter(task => {
                if (currentFilter === 'open' && task.completed) return false;
                if (currentFilter === 'completed' && !task.completed) return false;
                return true;
            });
            
            const currentIndex = openTasks.findIndex(task => task.id === currentOpenTaskId);
            let newIndex = currentIndex;
            
            if (direction === 'prev' && currentIndex > 0) {
                newIndex = currentIndex - 1;
            } else if (direction === 'next' && currentIndex < openTasks.length - 1) {
                newIndex = currentIndex + 1;
            }
            
            if (newIndex !== currentIndex && openTasks[newIndex]) {
                showInstructions(openTasks[newIndex].id);
            }
        }
        
        // Complete current task and advance
        function completeAndAdvance() {
            if (!currentOpenTaskId) {
                console.error('No task currently open');
                return;
            }
            
            const task = currentChecklist.find(t => t.id === currentOpenTaskId);
            if (!task) {
                console.error('Task not found:', currentOpenTaskId);
                return;
            }
            
            if (task.completed) {
                console.log('Task already completed');
                return;
            }
            
            // Use the same toggleTask function that works with the checkbox
            // This will show the confirmation dialog
            toggleTask(currentOpenTaskId, true);
        }
        
        // Show instructions content (separated for reuse)
        function showInstructionsContent(taskId, instructions) {
            // Set the current open task
            currentOpenTaskId = taskId;
            
            // Update the panel header with the current task's group name
            const groupInfo = getTaskGroupInfo(taskId);
            const panelTitle = document.getElementById('taskPanelTitle');
            if (groupInfo && groupInfo.name) {
                panelTitle.textContent = groupInfo.name;
            } else {
                panelTitle.textContent = 'All Tasks';
            }
            
            // Re-render the task list to update the current task highlighting
            renderTasks();
            
            // Initialize video if present
            setTimeout(() => {
                const video = document.getElementById(`task-video-${taskId}`);
                if (video) {
                    // Video now has native controls and click to play/pause
                    video.style.cursor = 'pointer';
                    
                    // Double-click to expand video
                    video.addEventListener('dblclick', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        expandVideo(taskId);
                    });
                    
                    // Ensure the expand button is on top of video controls
                    const container = document.getElementById(`video-container-${taskId}`);
                    if (container) {
                        // Find the expand button
                        const expandBtn = container.querySelector('button[title*="Expand"]');
                        if (expandBtn) {
                            // Ensure button is clickable and on top
                            expandBtn.style.pointerEvents = 'auto';
                            expandBtn.style.zIndex = '10001';
                            // Re-append to ensure it's on top
                            container.appendChild(expandBtn);
                        }
                    }
                }
            }, 100);
            
            // Get the task object
            const task = currentChecklist.find(t => t.id === taskId);
            if (!task) {
                console.error('Task not found:', taskId);
                return;
            }

            // Hide empty state and show content
            document.getElementById('emptyState').style.display = 'none';
            document.getElementById('instructionsContent').style.display = 'block';
            document.getElementById('instructionsPanel').querySelector('.close-btn').style.display = 'block';

            // Get the instructions content container
            const instructionsContent = document.getElementById('instructionsContent');
            
            // Completely clear any existing content and event listeners
            instructionsContent.innerHTML = '';
            
            // Remove any existing classes that might affect styling
            instructionsContent.className = 'instructions-content';

            let videoHtml = '';
            if (instructions.video_url || instructions.videoUrl) {
                const videoUrl = instructions.video_url || instructions.videoUrl;
                const videoType = instructions.video_type || instructions.videoType;
                
                // Check if this is an uploaded video (from Supabase storage)
                if (videoType === 'upload') {
                    // For uploaded videos, use HTML5 video player with click to play/pause
                    videoHtml = `
                        <div class="video-wrapper">
                            <div class="video-container" id="video-container-${taskId}" style="position: relative;">
                                <video id="task-video-${taskId}" 
                                       style="width: 100%; height: 100%; display: block; cursor: pointer;"
                                       onclick="toggleVideoPlay('${taskId}')"
                                       controls
                                       controlsList="nodownload"
                                       playsinline
                                       webkit-playsinline
                                       allowfullscreen
                                       webkitallowfullscreen
                                       mozallowfullscreen>
                                    <source src="${videoUrl}" type="video/mp4">
                                    Your browser does not support the video tag.
                                </video>
                                <button type="button"
                                        onclick="event.stopPropagation(); if(typeof expandVideo !== 'undefined') { expandVideo('${taskId}'); } else { console.error('expandVideo not defined yet'); alert('Please wait for page to load completely'); } return false;" 
                                        style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.8); 
                                               border: 2px solid white; border-radius: 6px; padding: 10px; cursor: pointer; 
                                               display: flex; align-items: center; justify-content: center;
                                               width: 44px; height: 44px; z-index: 10000; transition: all 0.2s ease;
                                               box-shadow: 0 2px 8px rgba(0,0,0,0.4); pointer-events: auto;"
                                        onmouseover="this.style.background='rgba(255,255,255,0.9)'; this.style.transform='scale(1.1)'; this.querySelector('svg').style.stroke='#000';"
                                        onmouseout="this.style.background='rgba(0,0,0,0.8)'; this.style.transform='scale(1)'; this.querySelector('svg').style.stroke='#fff';"
                                        title="Expand Video (or double-click video)">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" style="width: 24px; height: 24px;">
                                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="video-controls">
                                <button class="expand-video-btn" onclick="if(typeof expandVideo !== 'undefined') { expandVideo('${taskId}'); } else { console.error('expandVideo not defined yet'); alert('Please wait for page to load completely'); }">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                                    </svg>
                                    Expand Video
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    // For URL videos, convert YouTube/Vimeo URLs to embeddable format
                    let embedUrl = videoUrl;
                    if (embedUrl.includes('youtube.com/watch')) {
                        embedUrl = embedUrl.replace('watch?v=', 'embed/');
                    } else if (embedUrl.includes('youtu.be/')) {
                        embedUrl = embedUrl.replace('youtu.be/', 'youtube.com/embed/');
                    } else if (embedUrl.includes('vimeo.com/')) {
                        embedUrl = embedUrl.replace('vimeo.com/', 'player.vimeo.com/video/');
                    }
                    
                    videoHtml = `
                        <div class="video-wrapper">
                            <div class="video-container" id="video-container-${taskId}">
                                <iframe src="${embedUrl}" allowfullscreen id="task-video-${taskId}"></iframe>
                            </div>
                            <div class="video-controls">
                                <button class="expand-video-btn" onclick="if(typeof expandVideo !== 'undefined') { expandVideo('${taskId}'); } else { console.error('expandVideo not defined yet'); alert('Please wait for page to load completely'); }">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                        <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                                    </svg>
                                    Expand Video
                                </button>
                            </div>
                        </div>
                    `;
                }
            }

            // Clean the instruction content from any Quill editor artifacts
            const cleanContent = cleanQuillContent(instructions.content || '');
            
            // Add form embed if present (check both field names)
            let formEmbedHtml = '';
            const embedCode = instructions.form_embed_code || instructions.formEmbedCode;
            if (embedCode) {
                console.log('Found embed code for task:', taskId);
                console.log('Embed code:', embedCode);
                // Don't escape the HTML - it needs to be rendered as-is
                formEmbedHtml = `<div class="calendar-embed" style="margin: 20px 0; min-height: 500px;">${embedCode}</div>`;
            } else {
                console.log('No embed code found for task:', taskId);
            }
            
            // Get task position for navigation
            const openTasks = currentChecklist.filter(t => !t.completed);
            const currentIndex = openTasks.findIndex(t => t.id === taskId);
            const totalTasks = openTasks.length;
            const hasPrev = currentIndex > 0;
            const hasNext = currentIndex < totalTasks - 1;
            
            // Create fresh HTML content with navigation
            const instructionsHtml = `
                <div class="instructions-header">
                    <h2 class="instructions-title">${instructions.title}</h2>
                    <div style="display: flex; align-items: center;">
                        ${!task.completed ? `
                            <button class="header-complete-btn" onclick="completeAndAdvance()">
                                âœ“ Complete
                            </button>
                        ` : ''}
                        <div class="task-navigation">
                            <button class="task-nav-btn" onclick="navigateTask('prev')" ${!hasPrev ? 'disabled' : ''} title="Previous task">
                                â†
                            </button>
                            <span class="task-counter">${currentIndex + 1} / ${totalTasks}</span>
                            <button class="task-nav-btn" onclick="navigateTask('next')" ${!hasNext ? 'disabled' : ''} title="Next task">
                                â†’
                            </button>
                        </div>
                    </div>
                </div>
                ${videoHtml ? `<div class="video-section" style="background: transparent; padding: 20px;">${videoHtml}</div>` : ''}
                <div class="instructions-body" style="overflow-y: auto; background: white; padding: 20px; margin: 20px;">
                    ${cleanContent}
                    ${formEmbedHtml}
                </div>
            `;
            
            // Set the new content
            instructionsContent.innerHTML = instructionsHtml;
            
            // Add click event delegation for links within instructions
            instructionsContent.addEventListener('click', async (e) => {
                // Check if the clicked element is a link
                const link = e.target.closest('a');
                if (!link) return;
                
                const href = link.getAttribute('href');
                if (!href) return;
                
                if (href.startsWith('http://') || href.startsWith('https://')) {
                    // External links open in new tab
                    e.preventDefault();
                    window.open(href, '_blank');
                } else if (href.startsWith('#')) {
                    // Internal anchors - let them work normally
                    return;
                }
            });
            
            // Enable form functionality for any forms in the content
            enableInstructionForms();
            
            // Execute any calendar embed scripts after a short delay
            setTimeout(() => {
                const calendarEmbeds = instructionsContent.querySelectorAll('.calendar-embed script');
                calendarEmbeds.forEach(script => {
                    const newScript = document.createElement('script');
                    if (script.src) {
                        newScript.src = script.src;
                    } else {
                        newScript.textContent = script.textContent;
                    }
                    script.parentNode.replaceChild(newScript, script);
                });
            }, 100);
        }

        // Enable form functionality in instruction panels
        function enableInstructionForms() {
            const instructionsPanel = document.getElementById('instructionsContent');
            
            // Execute any scripts that were embedded in the content
            executeEmbeddedScripts(instructionsPanel);
            
            // Monitor for form submissions
            monitorFormSubmissions(instructionsPanel);
            
            // Find all forms in the instructions content
            const forms = instructionsPanel.querySelectorAll('form');
            
            forms.forEach(form => {
                // Prevent default form submission if no action is specified
                if (!form.action) {
                    form.addEventListener('submit', function(e) {
                        e.preventDefault();
                        console.log('Form submitted:', new FormData(form));
                        
                        // You can add custom form handling here
                        const formData = new FormData(form);
                        const formObject = {};
                        
                        for (let [key, value] of formData.entries()) {
                            formObject[key] = value;
                        }
                        
                        // Log form data and optionally send to webhook
                        console.log('Form data collected:', formObject);
                        
                        // Show success message
                        showFormSuccess(form);
                    });
                }
                
                // Add form styling classes
                form.classList.add('instruction-form');
            });

            // Find all input elements and style them
            const inputs = instructionsPanel.querySelectorAll('input, textarea, select');
            inputs.forEach(input => {
                input.classList.add('form-input');
            });

            // Find all buttons and style them
            const buttons = instructionsPanel.querySelectorAll('button');
            buttons.forEach(button => {
                if (button.type === 'submit' || !button.type) {
                    button.classList.add('form-button');
                }
            });

            // Ensure iframes are properly sized
            const iframes = instructionsPanel.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                if (!iframe.style.width) iframe.style.width = '100%';
                if (!iframe.style.minHeight) iframe.style.minHeight = '400px';
                if (!iframe.style.border) iframe.style.border = 'none';
                if (!iframe.style.borderRadius) iframe.style.borderRadius = '6px';
            });
        }

        // Execute embedded scripts in instruction content
        function executeEmbeddedScripts(container) {
            // Find script tags in the content
            const scriptElements = container.querySelectorAll('script');
            
            scriptElements.forEach(scriptEl => {
                try {
                    // Create a new script element
                    const newScript = document.createElement('script');
                    
                    // Copy attributes
                    Array.from(scriptEl.attributes).forEach(attr => {
                        newScript.setAttribute(attr.name, attr.value);
                    });
                    
                    // Copy script content or src
                    if (scriptEl.src) {
                        newScript.src = scriptEl.src;
                    } else {
                        newScript.textContent = scriptEl.textContent;
                    }
                    
                    // Replace the old script with the new one to execute it
                    scriptEl.parentNode.replaceChild(newScript, scriptEl);
                    
                    console.log('Executed embedded script:', newScript.src || 'inline script');
                } catch (error) {
                    console.error('Error executing embedded script:', error);
                }
            });
        }

        // Show form success message
        function showFormSuccess(form) {
            const existingMessage = form.querySelector('.form-success-message');
            if (existingMessage) {
                existingMessage.remove();
            }

            const successDiv = document.createElement('div');
            successDiv.className = 'form-success-message';
            successDiv.innerHTML = 'âœ“ Form submitted successfully!';
            form.appendChild(successDiv);

            // Remove success message after 3 seconds
            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }

        // Monitor for form submissions 
        function monitorFormSubmissions(container) {
            // Method 1: Monitor for direct form submissions
            const forms = container.querySelectorAll('form');
            forms.forEach(form => {
                form.addEventListener('submit', function(e) {
                    console.log('Form submitted directly');
                    setTimeout(() => handleFormSubmission(), 1000); // Delay to allow form processing
                });
            });

            // Method 2: Monitor for iframe changes (common with embedded forms)
            const iframes = container.querySelectorAll('iframe');
            iframes.forEach(iframe => {
                // Monitor for thank you messages appearing
                const checkForThankYou = () => {
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        if (iframeDoc) {
                            const textContent = iframeDoc.body.textContent.toLowerCase();
                            if (textContent.includes('thank you') || 
                                textContent.includes('success') || 
                                textContent.includes('submitted') ||
                                textContent.includes('confirmation') ||
                                textContent.includes('message sent')) {
                                console.log('Form submission detected via content change');
                                handleFormSubmission();
                                return true;
                            }
                        }
                    } catch (e) {
                        // Cross-origin restrictions - can't access iframe content
                        // Use alternative detection methods
                    }
                    return false;
                };

                // Check periodically for thank you messages
                const thankYouChecker = setInterval(() => {
                    if (checkForThankYou()) {
                        clearInterval(thankYouChecker);
                    }
                }, 2000);

                // Set up mutation observer for iframe load
                iframe.addEventListener('load', function() {
                    setTimeout(checkForThankYou, 1000); // Check 1 second after iframe loads
                });

                // Clean up interval when task is closed
                iframe.dataset.intervalId = thankYouChecker;
            });

            // Method 3: Listen for postMessage events (some forms send these)
            const messageListener = function(event) {
                if (event.data && typeof event.data === 'object') {
                    if (event.data.type === 'form_submitted' || 
                        event.data.action === 'submit' ||
                        event.data.status === 'success' ||
                        event.data.message === 'form_success') {
                        console.log('Form submission detected via postMessage:', event.data);
                        handleFormSubmission();
                    }
                }
            };
            
            window.addEventListener('message', messageListener);
            
            // Store the listener for cleanup
            container.dataset.messageListener = messageListener;
        }

        // Handle form submission
        function handleFormSubmission() {
            console.log('Form submission detected! Auto-completing task...');
            
            // Auto-complete the current task
            if (currentOpenTaskId) {
                const taskToComplete = currentChecklist.find(task => task.id === currentOpenTaskId);
                if (taskToComplete && !taskToComplete.completed) {
                    toggleTask(currentOpenTaskId, true);
                    
                    // Show success message
                    showFormSubmissionSuccess();
                }
            }
        }

        // Show form submission success message
        function showFormSubmissionSuccess() {
            // Create success notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(90deg, #10B981 0%, #059669 100%);
                color: white;
                padding: 16px 24px;
                border-radius: 8px;
                font-weight: 600;
                z-index: 10000;
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                animation: slideInFromRight 0.3s ease-out;
            `;
            notification.innerHTML = 'âœ“ Form submitted successfully! Task auto-completed.';
            
            // Add animation styles
            if (!document.getElementById('notification-styles')) {
                const style = document.createElement('style');
                style.id = 'notification-styles';
                style.textContent = `
                    @keyframes slideInFromRight {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes slideOutToRight {
                        from { transform: translateX(0); opacity: 1; }
                        to { transform: translateX(100%); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(notification);
            
            // Remove notification after 4 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutToRight 0.3s ease-out';
                setTimeout(() => notification.remove(), 300);
            }, 4000);
        }

        // Toggle task panel
        function toggleTaskPanel() {
            const panel = document.getElementById('taskPanel');
            
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
            } else {
                panel.classList.add('collapsed');
            }
        }
        
        // Toggle user dropdown
        function toggleUserDropdown() {
            const dropdown = document.getElementById('userDropdown');
            dropdown.classList.toggle('active');
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.user-menu')) {
                document.getElementById('userDropdown')?.classList.remove('active');
            }
        });
        
        // Close instructions
        function closeInstructions() {
            // Clear the current open task
            currentOpenTaskId = null;
            
            // Reset the panel title
            document.getElementById('taskPanelTitle').textContent = 'All Tasks';
            
            // Show empty state and hide content
            document.getElementById('emptyState').style.display = 'block';
            document.getElementById('instructionsContent').style.display = 'none';
            document.getElementById('instructionsPanel').querySelector('.close-btn').style.display = 'none';
            
            // Clear the instructions content completely
            const instructionsContent = document.getElementById('instructionsContent');
            instructionsContent.innerHTML = '';
            
            // Reset the content class
            instructionsContent.className = 'instructions-content';
            
            console.log('Instructions panel closed and reset');
        }

        // Show error
        function showError(message) {
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = `<div class="error">${message}</div>`;
        }

        // Initialize application
        async function init() {
            try {
                // Detect HighLevel environment first
                detectHighLevelEnvironment();
                
                const params = getUrlParams();
                console.log('URL parameters:', params);

                // Check for template variables that weren't replaced
                if (params.email === '{{user.email}}' || params.locationId === '{{location.id}}') {
                    showError('Invalid URL - template variables detected');
                    document.getElementById('app').innerHTML = `
                        <div style="text-align: center; padding: 50px; background: #FEE2E2; border-radius: 8px; margin: 20px;">
                            <h2 style="color: #DC2626; margin-bottom: 20px;">Invalid URL Parameters</h2>
                            <p style="color: #7F1D1D; font-size: 18px; margin-bottom: 20px;">
                                The URL contains template variables that need to be replaced with actual values.
                            </p>
                            <p style="color: #6B7280; background: #F3F4F6; padding: 12px; border-radius: 6px; margin: 20px 0; font-family: monospace; font-size: 14px;">
                                Current URL has:<br>
                                email = ${params.email || '(missing)'}<br>
                                locationId = ${params.locationId || '(missing)'}<br>
                                group = ${params.group || '(missing)'}
                            </p>
                            <p style="color: #7F1D1D; margin-bottom: 20px;">
                                For testing, use actual values like:<br>
                                <code style="background: #F3F4F6; padding: 8px; border-radius: 4px; display: inline-block; margin-top: 10px;">
                                    ?email=test@example.com&locationId=test123&group=dfy
                                </code>
                            </p>
                            <p style="color: #7F1D1D; margin-bottom: 30px;">
                                For production use, contact support:
                            </p>
                            <a href="mailto:support@dfycrm.com" style="
                                display: inline-block;
                                background: #DC2626;
                                color: white;
                                padding: 12px 30px;
                                border-radius: 8px;
                                text-decoration: none;
                                font-weight: bold;
                                font-size: 16px;
                            ">support@dfycrm.com</a>
                        </div>
                    `;
                    return;
                }

                if (!params.email || !params.locationId || !params.group) {
                    showError('Missing required parameters. The group parameter is required.');
                    document.getElementById('app').innerHTML = `
                        <div style="text-align: center; padding: 50px; background: #FEE2E2; border-radius: 8px; margin: 20px;">
                            <h2 style="color: #DC2626; margin-bottom: 20px;">Access Error</h2>
                            <p style="color: #7F1D1D; font-size: 18px; margin-bottom: 20px;">
                                This onboarding page requires valid email, locationId, and group parameters in the URL.
                            </p>
                            <p style="color: #6B7280; background: #F3F4F6; padding: 12px; border-radius: 6px; margin: 20px 0; font-family: monospace; font-size: 14px;">
                                Current parameters:<br>
                                email = ${params.email || '(missing)'}<br>
                                locationId = ${params.locationId || '(missing)'}<br>
                                group = ${params.group || '(missing)'}
                            </p>
                            <p style="color: #7F1D1D; margin-bottom: 30px;">
                                Please contact support for the correct onboarding link:
                            </p>
                            <a href="mailto:support@dfycrm.com" style="
                                display: inline-block;
                                background: #DC2626;
                                color: white;
                                padding: 12px 30px;
                                border-radius: 8px;
                                text-decoration: none;
                                font-weight: bold;
                                font-size: 16px;
                            ">support@dfycrm.com</a>
                        </div>
                    `;
                    return;
                }

                // Load user and tasks
                const user = await loadUser(params.email, params.locationId, params.group);
                
                currentUser = user;
                
                // Load fresh tasks and merge with user's checklist
                const dbTasks = await loadTasks();
                
                // Merge database tasks with user's existing checklist
                const userTaskMap = new Map(currentUser.checklist.map(t => [t.id, t]));
                const dbTaskIds = new Set(dbTasks.map(t => t.task_id));
                
                // Build new checklist by syncing with database
                const mergedChecklist = dbTasks
                    .map(dbTask => {
                        const existingUserTask = userTaskMap.get(dbTask.task_id);
                        
                        if (existingUserTask) {
                            // Update existing task with latest database info, keep completion status
                            return {
                                id: dbTask.task_id,
                                title: dbTask.task_title || dbTask.title || '',  // Use task_title from database
                                description: dbTask.task_description || dbTask.description || '',  // Use task_description from database
                                completed: existingUserTask.completed  // Preserve user's completion status
                            };
                        } else {
                            // New task from database
                            return {
                                id: dbTask.task_id,
                                title: dbTask.task_title || dbTask.title || '',
                                description: dbTask.task_description || dbTask.description || '',
                                completed: false
                            };
                        }
                    })
                    .sort((a, b) => {
                        const aPos = dbTasks.find(t => t.task_id === a.id)?.position || 999;
                        const bPos = dbTasks.find(t => t.task_id === b.id)?.position || 999;
                        return aPos - bPos;
                    });

                // Check if checklist needs updating (length changed, new tasks, or content changed)
                const needsUpdate = mergedChecklist.length !== currentUser.checklist.length ||
                    mergedChecklist.some((newTask, index) => {
                        const oldTask = currentUser.checklist[index];
                        return !oldTask || 
                               newTask.title !== oldTask.title || 
                               newTask.description !== oldTask.description ||
                               newTask.id !== oldTask.id;
                    });

                if (needsUpdate) {
                    console.log('Updating user checklist with database changes');
                    await updateUserChecklist(mergedChecklist);
                } else {
                    currentChecklist = currentUser.checklist;
                    updateProgress();
                }

                renderTasks();
                
                // Show personalized welcome if profile is completed
                checkExistingUserWelcome();
                
                // Auto-open first incomplete task for better UX
                const firstIncompleteTask = currentChecklist.find(t => !t.completed);
                if (firstIncompleteTask) {
                    setTimeout(() => {
                        showInstructions(firstIncompleteTask.id);
                    }, 500);
                }
                
            } catch (error) {
                console.error('Initialization error:', error);
                showError('Failed to load onboarding tasks. Please refresh the page or contact support.');
            }
        }

        // Profile completion functions
        function showProfilePopup(user) {
            console.log('Showing profile popup for user:', user.email);
            const overlay = document.getElementById('profileOverlay');
            overlay.style.display = 'flex';
            
            // Setup form submission
            const form = document.getElementById('profileForm');
            form.onsubmit = async function(e) {
                e.preventDefault();
                await submitProfile(user);
            };
            
            // Block access to tasks
            const taskList = document.getElementById('taskList');
            taskList.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #6B7280;">
                    <h3>Profile Completion Required</h3>
                    <p>Please complete your profile information to access your onboarding tasks.</p>
                </div>
            `;
        }
        
        async function submitProfile(user) {
            const submitBtn = document.querySelector('.profile-submit-btn');
            
            // Get form data
            const firstName = document.getElementById('firstName').value.trim();
            const lastName = document.getElementById('lastName').value.trim();
            const cellPhone = document.getElementById('cellPhone').value.trim();
            const companyName = document.getElementById('companyName').value.trim();
            
            // Validate required fields
            if (!firstName || !lastName || !cellPhone || !companyName) {
                alert('Please fill in all required fields.');
                return;
            }
            
            try {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Saving...';
                
                // Update user profile in database
                const { data, error } = await supabaseClient
                    .from('onboarding_users')
                    .update({
                        first_name: firstName,
                        last_name: lastName,
                        cell_phone: cellPhone,
                        company_name: companyName,
                        profile_completed: true,
                        notifications_enabled: true,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', user.id)
                    .select()
                    .single();
                
                if (error) throw error;
                
                console.log('Profile updated successfully:', data);
                
                // Update current user object
                currentUser = { ...currentUser, ...data };
                
                // Hide popup
                document.getElementById('profileOverlay').style.display = 'none';
                
                // Show personalized welcome
                showPersonalizedWelcome(currentUser);
                
                // Reload and render tasks
                await loadAndRenderTasks();
                
            } catch (error) {
                console.error('Error saving profile:', error);
                alert('Failed to save profile. Please try again.');
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Complete Profile & Continue';
            }
        }
        
        async function loadAndRenderTasks() {
            try {
                // Load fresh tasks and merge with user's checklist
                const dbTasks = await loadTasks();
                
                // Merge database tasks with user's existing checklist
                const userTaskMap = new Map(currentUser.checklist.map(t => [t.id, t]));
                
                // Build new checklist by syncing with database
                const mergedChecklist = dbTasks
                    .map(dbTask => {
                        const existingUserTask = userTaskMap.get(dbTask.task_id);
                        
                        if (existingUserTask) {
                            // Update existing task with latest database info, keep completion status
                            return {
                                id: dbTask.task_id,
                                title: dbTask.task_title || dbTask.title || '',
                                description: dbTask.task_description || dbTask.description || '',
                                completed: existingUserTask.completed
                            };
                        } else {
                            // New task from database
                            return {
                                id: dbTask.task_id,
                                title: dbTask.task_title || dbTask.title || '',
                                description: dbTask.task_description || dbTask.description || '',
                                completed: false
                            };
                        }
                    })
                    // All tasks are visible in the onboarding interface
                    ;
                
                // Update current checklist
                currentChecklist = mergedChecklist;
                currentUser.checklist = mergedChecklist;
                
                // Store task instructions
                dbTasks.forEach(task => {
                    taskInstructions[task.task_id] = {
                        title: task.instruction_title,
                        content: task.instruction_content,
                        video_url: task.video_url,
                        video_type: task.video_type,
                        form_embed_code: task.form_embed_code,
                        groupInfo: task.task_groups ? {
                            id: task.task_groups?.id,
                            name: task.task_groups?.group_name,
                            display_order: task.task_groups?.display_order
                        } : null
                    };
                });
                
                // Render the tasks
                renderTasks();
                
            } catch (error) {
                console.error('Error loading tasks after profile completion:', error);
                showError('Failed to load tasks after profile completion.');
            }
        }
        
        // Edit Profile Functions
        function openEditProfileModal() {
            if (!currentUser || !currentUser.profile_completed) {
                return;
            }
            
            // Pre-fill the form with current user data
            document.getElementById('editFirstName').value = currentUser.first_name || '';
            document.getElementById('editLastName').value = currentUser.last_name || '';
            document.getElementById('editCellPhone').value = currentUser.cell_phone || '';
            document.getElementById('editCompanyName').value = currentUser.company_name || '';
            document.getElementById('editEmail').value = currentUser.email || '';
            document.getElementById('editLocationId').value = currentUser.location_id || '';
            
            // Set notification toggle (default to true if not set)
            const notificationsEnabled = currentUser.notifications_enabled !== false;
            document.getElementById('notificationsToggle').checked = notificationsEnabled;
            
            // Setup form submission
            const form = document.getElementById('editProfileForm');
            form.onsubmit = async function(e) {
                e.preventDefault();
                await updateProfile();
            };
            
            // Show the modal
            document.getElementById('editProfileOverlay').style.display = 'flex';
        }
        
        function closeEditProfileModal() {
            document.getElementById('editProfileOverlay').style.display = 'none';
        }
        
        // Notification toggle handling
        let pendingNotificationChange = null;
        
        function handleNotificationToggleClick(event) {
            // Prevent default behavior
            event.preventDefault();
            event.stopPropagation();
            
            const toggle = document.getElementById('notificationsToggle');
            const currentlyChecked = toggle.checked;
            
            // If currently ON and trying to turn OFF, show confirmation
            if (currentlyChecked) {
                showOptOutConfirmation();
            } else {
                // If currently OFF, just turn it ON (no confirmation needed)
                toggle.checked = true;
            }
        }
        
        function handleNotificationToggle(event) {
            const toggle = event.target;
            const isNowChecked = toggle.checked;
            
            // If trying to turn OFF notifications, show confirmation
            if (!isNowChecked) {
                // Prevent the toggle from changing immediately
                event.preventDefault();
                toggle.checked = true; // Reset to checked state
                showOptOutConfirmation();
            }
        }
        
        function showOptOutConfirmation() {
            document.getElementById('confirmOptOutOverlay').style.display = 'flex';
        }
        
        function cancelOptOut() {
            // Reset toggle to ON position
            document.getElementById('notificationsToggle').checked = true;
            document.getElementById('confirmOptOutOverlay').style.display = 'none';
        }
        
        function confirmOptOut() {
            // Turn off notifications
            document.getElementById('notificationsToggle').checked = false;
            document.getElementById('confirmOptOutOverlay').style.display = 'none';
        }
        
        async function updateProfile() {
            const submitBtn = document.querySelector('#editProfileForm button[type="submit"]');
            
            // Get form data
            const firstName = document.getElementById('editFirstName').value.trim();
            const lastName = document.getElementById('editLastName').value.trim();
            const cellPhone = document.getElementById('editCellPhone').value.trim();
            const companyName = document.getElementById('editCompanyName').value.trim();
            const notificationsEnabled = document.getElementById('notificationsToggle').checked;
            
            // Validate required fields
            if (!firstName || !lastName || !cellPhone || !companyName) {
                alert('Please fill in all required fields.');
                return;
            }
            
            try {
                submitBtn.disabled = true;
                submitBtn.textContent = 'Updating...';
                
                // Update user profile in database
                const { data, error } = await supabaseClient
                    .from('onboarding_users')
                    .update({
                        first_name: firstName,
                        last_name: lastName,
                        cell_phone: cellPhone,
                        company_name: companyName,
                        notifications_enabled: notificationsEnabled,
                        updated_at: new Date().toISOString()
                    })
                    .eq('id', currentUser.id)
                    .select()
                    .single();
                
                if (error) throw error;
                
                console.log('Profile updated successfully:', data);
                
                // Update current user object
                currentUser = { ...currentUser, ...data };
                
                // Update the welcome display with new information
                showPersonalizedWelcome(currentUser);
                
                // Close modal
                closeEditProfileModal();
                
                // Show success message
                alert('Profile updated successfully!');
                
            } catch (error) {
                console.error('Error updating profile:', error);
                alert('Failed to update profile. Please try again.');
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Update Profile';
            }
        }
        
        // Show personalized welcome message
        function showPersonalizedWelcome(user) {
            // Always update email in dropdown (even if profile not complete)
            if (user.email) {
                document.getElementById('dropdownUserEmail').textContent = user.email;
            }
            
            if (!user.profile_completed || !user.first_name) {
                // Even without profile, update what we have
                document.getElementById('userInitials').textContent = 'U';
                document.getElementById('userName').textContent = 'User';
                document.getElementById('dropdownUserName').textContent = 'User';
                document.getElementById('dropdownCompany').textContent = '';
                return;
            }
            
            // Build welcome message for completed profiles
            const fullName = [user.first_name, user.last_name].filter(n => n).join(' ');
            
            // Update navbar user display
            const userInitials = (user.first_name[0] + (user.last_name ? user.last_name[0] : '')).toUpperCase();
            const userName = user.first_name || 'Guest';
            
            document.getElementById('userInitials').textContent = userInitials;
            document.getElementById('userName').textContent = userName;
            
            // Update dropdown info
            document.getElementById('dropdownUserName').textContent = fullName;
            document.getElementById('dropdownUserEmail').textContent = user.email;
            document.getElementById('dropdownCompany').textContent = user.company_name || '';
        }
        
        // Check and show welcome for existing users
        function checkExistingUserWelcome() {
            if (currentUser && currentUser.profile_completed) {
                showPersonalizedWelcome(currentUser);
            }
        }

        // Task completion confirmation functions
        async function confirmTaskComplete() {
            if (!pendingTaskComplete) return;
            
            const autoAdvance = pendingTaskComplete.autoAdvance;
            const taskId = pendingTaskComplete.taskId;
            
            document.getElementById('taskCompleteOverlay').style.display = 'none';
            await performTaskToggle(taskId, true);
            
            // Auto-advance to next task if requested
            if (autoAdvance) {
                const openTasks = currentChecklist.filter(t => !t.completed);
                const nextTask = openTasks[0]; // Get first incomplete task
                if (nextTask) {
                    setTimeout(() => {
                        showInstructions(nextTask.id);
                    }, 500); // Small delay for smooth transition
                } else {
                    // All tasks complete!
                    document.getElementById('emptyState').innerHTML = `
                        <h2>ðŸŽ‰ Congratulations!</h2>
                        <p>You've completed all your onboarding tasks!</p>
                    `;
                    document.getElementById('emptyState').style.display = 'block';
                    document.getElementById('instructionsContent').style.display = 'none';
                }
            }
            
            pendingTaskComplete = null;
        }
        
        function cancelTaskComplete() {
            document.getElementById('taskCompleteOverlay').style.display = 'none';
            pendingTaskComplete = null;
        }
        
        // Modal click handlers
        document.addEventListener('click', function(event) {
            // Close edit profile modal when clicking outside
            const editProfileOverlay = document.getElementById('editProfileOverlay');
            if (event.target === editProfileOverlay) {
                closeEditProfileModal();
            }
            
            // Close task complete modal when clicking outside
            const taskCompleteOverlay = document.getElementById('taskCompleteOverlay');
            if (event.target === taskCompleteOverlay) {
                cancelTaskComplete();
            }
        });

        // Gamification Functions
        function initializeGamification() {
            // Initialize completion sounds
            initializeSounds();
            
            // Load streak data from localStorage
            loadStreakData();
            
            // Show streak counter if user has a streak
            updateStreakDisplay();
        }

        function initializeSounds() {
            // Create multiple sound variations for variety
            const soundUrls = [
                'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBi9/zPDTgDYGHm3A7OWVLwkQVazn77BdGAg+lt3vy3spBiR8x+/djjcGHWq07OedQAoQUqPg8bllHgg2jdT0x3kpBSl7yu7ZizoGHWe57OmZOgsOUKXj8K5iIwc2h9Pzx3kpBSh+zO7ajDkGH2q57OmYOwoOUKXh8K5iIAU2h9Pyx3srBSh+zO3ajDcGH2m07OmYOwoOUKXh8K1iIAU2h9Pyx3srBSh+zO3ajDcGH2m07OmYOwoOUKXh8a5iIAU2h9Pyx3srBSh+zO3ajDcGH2m07OmYOwoOUKXh8a5iIAU2h9Pyxnkq',
                'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N+QQAoUXrTp66hVFApGn+DyvmwhBi9/zPDTgDYGHm3A7OWVLwkQVazn77BdGAg+lt3vy3spBiR8x+/djjcGHWq07OedQAoQUqPg8bllHgg2jdT0x3kpBSl7yu7ZizoGHWe57OmZOgsOUKXj8K5iIwc2h9Pzx3kpBSh+zO7ajDkGH2q57OmYOwoOUKXh8K5iIAU2h9Pyx3srBSh+zO3ajDcGH2m07OmYOwoOUKXh8K1iIAU2h9Pyx3srBSh+zO3ajDcGH2m07OmYOwoOUKXh8a5iIAU2h9Pyx3srBSh+zO3ajDcGH2m07OmYOwoOUKXh8a5iIAU2h9Pyxnkq'
            ];
            
            completionSounds = soundUrls.map(url => {
                const audio = new Audio(url);
                audio.volume = 0.3;
                return audio;
            });
        }

        function playCompletionSound() {
            // Play a random completion sound
            const randomIndex = Math.floor(Math.random() * completionSounds.length);
            const sound = completionSounds[randomIndex].cloneNode();
            sound.play().catch(e => console.log('Could not play sound:', e));
        }

        function loadStreakData() {
            const savedStreak = localStorage.getItem('taskStreak');
            const savedDate = localStorage.getItem('lastCompletionDate');
            
            if (savedStreak) {
                currentStreak = parseInt(savedStreak);
            }
            if (savedDate) {
                lastCompletionDate = new Date(savedDate);
            }
        }

        function updateStreak() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            if (lastCompletionDate) {
                const lastDate = new Date(lastCompletionDate);
                lastDate.setHours(0, 0, 0, 0);
                
                const dayDiff = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
                
                if (dayDiff === 0) {
                    // Same day, streak continues
                } else if (dayDiff === 1) {
                    // Next day, increment streak
                    currentStreak++;
                } else {
                    // Streak broken, reset to 1
                    currentStreak = 1;
                }
            } else {
                // First completion
                currentStreak = 1;
            }
            
            lastCompletionDate = new Date();
            
            // Save to localStorage
            localStorage.setItem('taskStreak', currentStreak.toString());
            localStorage.setItem('lastCompletionDate', lastCompletionDate.toISOString());
            
            updateStreakDisplay();
        }

        function updateStreakDisplay() {
            const streakCounter = document.getElementById('streakCounter');
            const streakText = document.getElementById('streakText');
            
            if (currentStreak > 0) {
                streakCounter.style.display = 'flex';
                streakText.textContent = `${currentStreak} day${currentStreak > 1 ? 's' : ''} streak!`;
                
                if (currentStreak >= 3) {
                    streakCounter.classList.add('active');
                } else {
                    streakCounter.classList.remove('active');
                }
            } else {
                streakCounter.style.display = 'none';
            }
        }

        function createConfetti() {
            const container = document.getElementById('confettiContainer');
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE'];
            
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti-piece';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 0.5 + 's';
                    container.appendChild(confetti);
                    
                    setTimeout(() => confetti.remove(), 3000);
                }, i * 30);
            }
        }

        function showSuccessBadge(message) {
            const badge = document.createElement('div');
            badge.className = 'success-badge';
            badge.textContent = message;
            document.body.appendChild(badge);
            
            setTimeout(() => badge.remove(), 1000);
        }

        function checkMilestones() {
            const completedCount = currentChecklist.filter(t => t.completed).length;
            const totalCount = currentChecklist.length;
            const percentage = (completedCount / totalCount) * 100;
            
            let milestone = null;
            
            if (percentage === 100) {
                milestone = {
                    title: 'ðŸŽ‰ All Tasks Complete!',
                    message: "You're a productivity champion!"
                };
            } else if (percentage >= 75 && percentage < 100) {
                milestone = {
                    title: 'ðŸš€ 75% Complete!',
                    message: 'Almost there! Keep pushing!'
                };
            } else if (percentage >= 50 && percentage < 75) {
                milestone = {
                    title: 'â­ Halfway There!',
                    message: "You're doing amazing!"
                };
            } else if (percentage >= 25 && percentage < 50) {
                milestone = {
                    title: 'ðŸ’ª 25% Complete!',
                    message: 'Great progress! Keep it up!'
                };
            } else if (completedCount === 1) {
                milestone = {
                    title: 'ðŸŽ¯ First Task Done!',
                    message: "You've started your journey!"
                };
            }
            
            if (milestone && !sessionStorage.getItem(`milestone_${percentage}`)) {
                showMilestoneNotification(milestone.title, milestone.message);
                sessionStorage.setItem(`milestone_${percentage}`, 'true');
            }
        }

        function showMilestoneNotification(title, message) {
            const notification = document.getElementById('milestoneNotification');
            const titleEl = document.getElementById('milestoneTitle');
            const messageEl = document.getElementById('milestoneMessage');
            
            titleEl.textContent = title;
            messageEl.textContent = message;
            
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }

        function celebrateCompletion() {
            // Play sound
            playCompletionSound();
            
            // Show visual effects
            createConfetti();
            
            // Show success message
            const messages = [
                'Awesome! ðŸŽ‰',
                'Great job! ðŸ’ª',
                'Keep it up! ðŸš€',
                'You rock! â­',
                'Amazing! ðŸŽ¯',
                'Fantastic! ðŸ”¥',
                'Brilliant! âœ¨'
            ];
            const randomMessage = messages[Math.floor(Math.random() * messages.length)];
            showSuccessBadge(randomMessage);
            
            // Update streak
            updateStreak();
            
            // Check for milestones
            setTimeout(() => checkMilestones(), 500);
        }

        // Make functions globally accessible for onclick handlers
        window.expandVideo = expandVideo;
        window.exitExpandedVideo = exitExpandedVideo;
        window.toggleVideoPlay = toggleVideoPlay;
        window.showInstructions = showInstructions;
        window.completeAndAdvance = completeAndAdvance;
        window.navigateTask = navigateTask;
        window.toggleTask = toggleTask;
        window.confirmTaskComplete = confirmTaskComplete;
        window.cancelTaskComplete = cancelTaskComplete;
        window.toggleTaskPanel = toggleTaskPanel;
        window.filterTasks = filterTasks;
        window.searchTasks = searchTasks;

        // Start the application
        document.addEventListener('DOMContentLoaded', () => {
            init();
            initializeGamification();
            
            // Handle fullscreen changes
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        });
        
        function handleFullscreenChange() {
            const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
            
            if (fullscreenElement) {
                // Entering fullscreen
                const video = fullscreenElement.querySelector('video');
                if (video) {
                    video.style.width = '100%';
                    video.style.height = '100%';
                    video.style.objectFit = 'contain';
                }
            } else {
                // Exiting fullscreen - restore normal styles
                const videos = document.querySelectorAll('video');
                videos.forEach(video => {
                    if (!video.closest('[data-expanded="true"]')) {
                        // Reset to normal styles if not in custom expanded mode
                        video.style.width = '';
                        video.style.height = '';
                        video.style.objectFit = '';
                    }
                });
            }
        }
    </script>
    
    <!-- Video Progress Tracking -->
    <script src="video-progress-tracker.js"></script>
    <script>
        // Initialize video progress tracker
        let videoProgressTracker = null;
        
        // Initialize tracker when user is authenticated
        function initVideoProgressTracker() {
            if (currentUser && window.VideoProgressTracker) {
                videoProgressTracker = new VideoProgressTracker(supabase, currentUser);
                console.log('Video progress tracker initialized');
            }
        }
        
        // Track video for current task
        function trackTaskVideo(taskId) {
            if (!videoProgressTracker) return;
            
            const videoElement = document.getElementById(`task-video-${taskId}`);
            if (videoElement && videoElement.tagName === 'VIDEO') {
                // Set requirement flag if task requires video completion
                const task = allTasks.find(t => t.id === taskId);
                if (task) {
                    videoProgressTracker.setVideoRequirement(taskId, task.require_video_completion);
                }
                
                // Initialize tracking for this video
                videoProgressTracker.initializeVideo(taskId, videoElement);
            }
        }
        
        // Check if user can proceed to next task (video gating)
        async function canProceedToNextTask(currentTaskId) {
            if (!currentUser || !currentTaskId) return true;
            
            try {
                const { data, error } = await supabase.rpc('can_proceed_to_next_task', {
                    p_user_id: currentUser.id,
                    p_current_task_id: currentTaskId
                });
                
                if (error) {
                    console.error('Error checking task progression:', error);
                    return true; // Allow progression on error
                }
                
                return data;
            } catch (error) {
                console.error('Error checking task progression:', error);
                return true;
            }
        }
        
        // Override showTask to include video tracking
        const originalShowTask = window.showTask;
        window.showTask = async function(taskId) {
            // Check if user can proceed from previous task (video gating)
            const currentTaskElement = document.querySelector('.task-item.active');
            if (currentTaskElement) {
                const currentTaskId = currentTaskElement.dataset.taskId;
                const currentTask = allTasks.find(t => t.id === currentTaskId);
                
                if (currentTask && currentTask.gate_next_task_on_video) {
                    const canProceed = await canProceedToNextTask(currentTaskId);
                    if (!canProceed) {
                        // Check video progress for more specific feedback
                        const progress = await videoProgressTracker?.getProgress(currentTaskId);
                        const percentage = progress?.watch_percentage || 0;
                        
                        alert(`Please complete the video in the current task before proceeding.\n\nVideo progress: ${Math.round(percentage)}% (95% required)`);
                        return;
                    }
                }
            }
            
            // Call original showTask
            originalShowTask(taskId);
            
            // Initialize video tracking for new task
            setTimeout(() => trackTaskVideo(taskId), 100);
        };
        
        // Initialize tracker when auth state changes
        supabase.auth.onAuthStateChange((event, session) => {
            if (session?.user) {
                setTimeout(initVideoProgressTracker, 500);
            }
        });
    </script>
</body>
</html>